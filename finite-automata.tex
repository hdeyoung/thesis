\chapter{Preliminaries: Automata}\label{ch:automata}

In this \lcnamecref{ch:automata}, we review the definitions of alphabets, words, languages, and automata that we will use in the running examples throughout this document.
% The classic text by \textcite{Hopcroft+Ullman:??} is a excellent reference.
Our definitions, though equivalent to the classical ones found in \textcite{Hopcroft+Ullman:??}'s text, differ slightly, having been tuned for the particular applications in this document.

\section{Alphabets, words, and languages}

An alphabet $\ialph$ is simply a set of symbols, $a \in \ialph$.
A finite word $w$ over the alphabet $\ialph$ is then a (possibly empty) finite sequence of symbols drawn from $\ialph$;
we denote the empty word by $\emp$.
The finite words form a free monoid under concatenation, with $\emp$ being the unit.
We denote by $\finwds{\ialph}$ the set of all finite words over $\ialph$.

It is also possible to construct infinite words.
An infinite word over the alphabet $\ialph$ is a countably infinite sequence of letters drawn from $\ialph$;
we denote the set of all infinite words over $\ialph$ by $\infinwds{\ialph}$.
We also use $\wds{\ialph}$ to denote the set of all words -- finite or infinite -- over the alphabet $\ialph$; that is, $\wds{\ialph} = \finwds{\ialph} \union \infinwds{\ialph}$.

A language is a set of words.
Depending on the context, it will be a subset of either $\wds{\ialph}$, $\infinwds{\ialph}$, or $\finwds{\ialph}$.

% It will sometimes be useful to work with an augmented alphabet.
% Given a symbol $c \notin \ialph$, we may form the augmented alphabet $\augalph{\ialph}{c} = \ialph \union \{c\}$.
% The augmented alphabet $\augalph{\ialph}{\emp}$ is the most

% \subsection{Endmarked alphabets and words}

% An endmarked alphabet $\ealph{\ialph}$ is a pair $\ealph{\ialph} = (, )$ of finite alphabets $ $ and $ $.

\section{Nondeterministic and \aclp*{DFA}}

\begin{definition}
  \Iac{NFA} over a finite input alphabet $\ialph$ is a triple $\aut{A} = (Q, \nfapow, F)$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$;
  \item a \vocab{transition function}, $\nfapow\colon Q \times \ialph \to \pow{Q}$ such that $\nfapow(q, a) \neq \emptyset$ for all states $q \in Q$ and input symbols $a \in \ialph$; and
  \item a subset of \vocab{final states}, $F \subseteq Q$,
  \end{itemize}
  If $q' \in \nfapow(q, a)$, then we say that $q'$ is an \emph{$a$-successor} of $q$ and write $q \nfareduces[a] q'$.
  The condition placed on $\nfapow$ thus serves to ensure that, for all input symbols $a$, each state $q$ has an $a$-successor -- that is, that the \ac{NFA} $\aut{A}$ cannot get stuck.

  The transition function $\nfapow$ can be lifted to a relation involving finite input words: For each word $w = a_1 \wc a_2 \dotsm a_n \in \finwds{\ialph}$, define a relation $\mathord{\nfareduces[\smash{w}]} \subseteq Q \times Q$ such that $q \nfareduces[w] q'$ when $q = q_0 \nfareduces[a_1] q_1 \nfareduces[a_2] \dotsb \nfareduces[a_n] q_n = q'$ for some sequence of states $q_0, q_1, \dotsc, q_n \in Q$.

  The \ac{NFA} $\aut{A}$ accepts input word $w$ from state $q$ if there exists a state $q' \in Q$ such that $q \nfareduces[w] q' \in F$;
  otherwise, the automaton rejects word $w$ from state $q$.
  The language of all words accepted by automaton $\aut{A}$ from state $q$ is denoted by $\autlang{\aut{A}}{q}$.%
  \footnote{We sometimes omit the subscript if the automaton is clear from the context.}
\end{definition}

Notice that, unlike the classical definition of \acp{NFA}, this definition does not fix an initial state for the automaton.
This is because we will be primarily interested in the operational aspects of \iac{NFA}, rather than its linguistic aspects.

\begin{example}
  \begin{marginfigure}
    \begin{equation*}
      \mathllap{\aut{A}_1 = {}}
      \begin{tikzpicture}[baseline=(q_0.base)]
        \graph [automaton] {
          q_0
           -> [loop above, "a,b"]
          q_0
           -> ["b"]
          q_1 [accepting]
           -> ["a,b"]
          q_2
           -> [loop above, "a,b"]
          q_2;
        };
      \end{tikzpicture}
    \end{equation*}
    \caption{\Iac*{NFA} that accepts, from state $q_0$, exactly those words that end with $b$.}\label{fig:nfa-example-ends-b}
  \end{marginfigure}
  %
  As a concrete example, consider the \ac{NFA} $\aut{A}_1$ over the input alphabet $\ialph = \set{a, b}$ that is depicted in \cref{fig:nfa-example-ends-b}.
  This \ac{NFA} accepts, from state $q_0$, exactly those words that end with $b$.
  For comparison, the only word accepted from state $q_1$ is $\emp$.
  This \ac{NFA} is indeed nondeterministic, as both $q_0 \nfareduces[\smash{b}] q_0$ and $q_0 \nfareduces[\smash{b}] q_1$ hold.
\end{example}

\begin{definition}
  \Iacf{DFA} over a finite input alphabet $\ialph$ is \iac{NFA} $\aut{A} = (Q, \nfapow, F)$ over $\ialph$ in which $\nfapow(q, a)$ is a singleton set for all states $q$ and input symbols $a$.
  In this case, we write $\dfanext$ for the function from $Q \times \ialph$ to $Q$ that underlies $\nfapow$.
\end{definition}

\begin{example}
  \begin{marginfigure}
    \begin{equation*}
      \mathllap{\aut{A}_2 = {}}
      \begin{tikzpicture}[baseline=(s_0.base)]
        \graph [automaton] {
          s_0
           -> [loop above, "a"]
          s_0
           -> [bend left, "b"]
          s_1 [accepting]
           -> [loop above, "b"]
          s_1
           -> [bend left, "a"]
          s_0;
        };
      \end{tikzpicture}
    \end{equation*}
    \caption{\Iac*{DFA} that accepts, from state $s_0$, exactly those words that end with $b$.}\label{fig:dfa-example-ends-b}
  \end{marginfigure}
  \Cref{fig:dfa-example-ends-b} depicts \iac{DFA} over the input alphabet $\ialph = \set{a, b}$ that accepts, from state $s_0$, exactly those words that end with $b$.
  For comparison, the empty word $\emp$, too, is accepted from the state $s_1$.
\end{example}

\subsection{\acs*{NFA} bisimilarity}

In later \lcnamecrefs{ch:ordered-bisimilarity}, we will refer to a notion of bisimilarity for \acp{NFA} that was originally developed by \textcite{Milner:??}.

In general, two objects are bisimilar if they cannot be distinguished by an observer.
Here, \ac{NFA} bisimilarity is a relation on states, and the observer may only observe whether the empty word, $\emp$, is accepted or rejected by the given state.
% Two \ac{NFA} states are bisimilar if their successors are bisimilar and if they behave equivalently on the empty word, $\emp$.
%
\begin{definition}% [\ac*{NFA} bisimilarity]
  Let $\aut{A}_1 = (Q_1, \nfapow_1, F_1)$ and $\aut{A}_2 = (Q_2, \nfapow_2, F_2)$ be \acp{NFA} over an input alphabet $\ialph$.
  An \emph{\acs{NFA} bisimulation} between $\aut{A}_1$ and $\aut{A}_2$ is a binary relation on states, $\mathord{\simu{R}} \subseteq Q_1 \times Q_2$, that satisfies the following conditions.
  \begin{description}[labelindent=\parindent, leftmargin=\dimexpr\leftmargin+\parindent\relax]
  \item[Input bisimilarity]
    If $s \simu{R}^{-1}\nfareduces[a] q'$, then $s \nfareduces[a]\simu{R}^{-1} q'$;
    symmetrically, if $q \simu{R}\nfareduces[a] s'$, then $q \nfareduces[a]\simu{R} s'$.
    (See the adjacent \lcnamecref{fig:nfa-bisim:diagrams}.)% 
    \begin{marginfigure}
      \begin{equation*}
        \begin{tikzcd}
          q \rar[reduces]{a} \dar[relation][swap]{\simu{R}}
            & q\mathrlap{'} \dar[relation, exists]{\simu{R}}
          \\[.5ex]
          s \rar[reduces, exists]{a} & s\smash{\mathrlap{'}}
        \end{tikzcd}
        \qquad
        \begin{tikzcd}
          q \rar[reduces, exists]{a} \dar[relation][swap]{\simu{R}}
            & q\mathrlap{'} \dar[relation, exists]{\simu{R}}
          \\[.5ex]
          s \rar[reduces]{a} & s\smash{\mathrlap{'}}
        \end{tikzcd}
      \end{equation*}
      \caption{\Acs*{NFA} input bisimilarity, in diagrams}\label{fig:nfa-bisim:diagrams}
    \end{marginfigure}%

  \item[Finality]
    If $q \simu{R} s$, then $q \in F_1$ if, and only if, $s \in F_2$.
  \end{description}
  \vocab{\ac{NFA} bisimilarity} between $\aut{A}_1$ and $\aut{A}_2$, written $\asim_{\aut{A}_1,\aut{A}_2}$, is the largest bisimulation between $\aut{A}_1$ and $\aut{A}_2$.
  We will usually omit the subscripts because the automata are nearly always clear from context.
\end{definition}

Often, as a matter of convenience, \ac{NFA} bisimilarity is defined on the disjoint union of two \acp{NFA}.
Bisimilarity is then an equivalence relation.
Here we choose to keep the two automata distinct and prove reflexivity, symmetry, and transitivity, not in their strictest form, but in forms that apply to bisimilarity as defined above.

\begin{theorem}\label{thm:nfa-bisim-refl}
  Let $\aut{A} = (Q, \nfapow, F)$ be \iac{NFA} over an input alphabet $\ialph$.
  Then equality on $Q$ is a bisimulation between $\aut{A}$ and itself.
  Moreover, $q \asim q$ for all $q \in Q$.
\end{theorem}
\begin{proof}
  By checking that equality on $Q$ satisfies the conditions of a bisimulation between $\aut{A}$ and itself.
\end{proof}

\begin{theorem}\label{thm:nfa-bisim-sym}
  Let $\aut{A}_1 = (Q_1, \nfapow_1, F_1)$ and $\aut{A}_2 = (Q_2, \nfapow_2, F_2)$ be \acp{NFA} over an input alphabet $\ialph$, and let $\simu{R}$ be \iac{NFA} bisimulations between $\aut{A}_1$ and $\aut{A}_2$.
  Then its relational inverse, $\simu{R}^{-1}$, is a bisimulation between $\aut{A}_2$ and $\aut{A}_1$.
  Moreover, for all $q_1 \in Q_1$ and $q_2 \in Q_2$, if $q_1 \asim q_2$, then $q_2 \asim q_1$.
\end{theorem}
\begin{proof}
  By checking that $\simu{R}^{-1}$ satisfies the conditions of a bisimulation between $\aut{A}_2$ and $\aut{A}_1$.
\end{proof}

\begin{theorem}\label{thm:nfa-bisim-trans}
  Let $\aut{A}_1 = (Q_1, \nfapow_1, F_1)$, $\aut{A}_2 = (Q_2, \nfapow_2, F_2)$, and $\aut{A}_3 = (Q_3, \nfapow_3, F_3)$ be \acp{NFA} over an input alphabet $\ialph$, and let $\simu{R}$ and $\simu{S}$ be \ac{NFA} bisimulations between $\aut{A}_1$ and $\aut{A}_2$ and between $\aut{A}_2$ and $\aut{A}_3$, respectively.
  Then their relational composition, $\simu{R}\simu{S}$, is a bisimulation between $\aut{A}_1$ and $\aut{A}_3$.
  Moreover, for all $q_1 \in Q_1$ and $q_2 \in Q_2$ and $q_3 \in Q_3$, if $q_1 \asim q_2$ and $q_2 \asim q_3$, then $q_1 \asim q_3$.
\end{theorem}
\begin{proof}
  By checking that $\simu{R}\simu{S}$ satisfies the conditions of a bisimulation between $\aut{A}_1$ and $\aut{A}_3$.
  % By proving that $\Set{ (q, r) \in Q_1 \times Q_3 \given \exists s \in Q_2.\, (q \asim s) \land (s \asim r) }$ is \iac{NFA} bisimulation between $\aut{A}_1$ and $\aut{A}_3$.
\end{proof}

% Notice that these \lcnamecrefs{thm:nfa-bisim-sym} are symmetry- and transitivity-like properties, but because distinct automata are used, they cannot be symmetry and transitivity in a strict sense.
When \ac{NFA} bisimilarity is employed as an endorelation on the states of a single \ac{NFA}, $\aut{A}$, bisimilarity is a bona fide equivalence relation.%
%
\begin{corollary}
  Let $\aut{A}$ be \iac{NFA} over an input alphabet $\ialph$.
  \Ac{NFA} bisimilarity on $\aut{A}$ is reflexive, symmetric, and transitive.
\end{corollary}
% %
% \begin{proof}
%   \Ac{NFA} bisimilarity can be proved to be reflexive by showing that the state equality relation is \iac{NFA} bisimulation.
%   \Cref{thm:nfa-bisim-sym,thm:nfa-bisim-trans} prove that \ac{NFA} bisimilarity on $\aut{A}$ is symmetric and transitive.
% \end{proof}

The input bisimilarity condition satisfied by \iac{NFA} bisimulation can be lifted to a condition on words, not just input symbols.
%
\begin{theorem}\label{thm:nfa-bisim:words}
  Let $\aut{A}_1 = (Q_1, \nfapow_1, F_1)$ and $\aut{A}_2 = (Q_2, \nfapow_2, F_2)$ be \acp{NFA} over an input alphabet $\ialph$, and let $\simu{R}$ be \iac{NFA} bisimulation for $\aut{A}_1$ and $\aut{A}_2$.
  Then $s \simu{R}^{-1}\nfareduces[w] q'$ implies $s \nfareduces[w]\simu{R}^{-1} q'$; moreover, $q \simu{R}\nfareduces[w] s'$ implies $q \nfareduces[w]\simu{R} s'$.
\end{theorem}
%
\begin{proof}
  By induction over the structure of word $w$.
\end{proof}


\Ac{NFA} bisimilarity implies language equivalence, but, because of nondeterminism, the converse does not hold.
%
\begin{theorem}
  Let $\aut{A}_1 = (Q_1, \nfapow_1, F_1)$ and $\aut{A}_2 = (Q_2, \nfapow_2, F_2)$ be \acp{NFA} over an input alphabet $\ialph$.
  Then $q \asim s$ implies $\autlang{\aut{A}_1}{q} = \autlang{\aut{A}_2}{s}$.
\end{theorem}
%
\begin{proof}
  Because bisimilarity has a symmetry-like property~\parencref{thm:nfa-bisim-sym}, it suffices to show that $q \asim s$ implies $\autlang{\aut{A}_1}{q} \subseteq \autlang{\aut{A}_2}{s}$.
  Let $q \in Q_1$ and $s \in Q_2$ be bisimilar states, and choose an arbitrary word $w$ that is accepted from state $q$.
  By definition, $q \nfareduces[w] q'_w \in F_1$ for some state $q'_w$.
  It follows from \cref{thm:nfa-bisim:words} and the finality condition that $s \nfareduces[w] s'_w \in F_2$, for some state $s'_w$, and so $w$ is also accepted from state $s$.
\end{proof}
%
\begin{falseclaim}
  Let $\aut{A}_1 = (Q_1, \nfapow_1, F_1)$ and $\aut{A}_2 = (Q_2, \nfapow_2, F_2)$ be \acp{NFA} over an input alphabet $\ialph$.
  Then $\autlang{\aut{A}_1}{q} = \autlang{\aut{A}_2}{s}$ implies $q \asim s$.
\end{falseclaim}
%
\begin{proof}[Counterexample]
  Choose the \acp{NFA} $\aut{A}_1$ and $\aut{A}_2$ given in \cref{fig:nfa-example-ends-b,fig:dfa-example-ends-b}.
  Although the languages accepted by states $q_0$ and $s_0$ are the same, the two states are \emph{not} bisimilar.

  For the sake of deriving a contradiction, assume that $q_0 \asim s_0$.
  % and its symmetric reflection, $s_0 \asim q_0$.
  Because $q_0$ is one of the $b$-successors of $q_0$, it follows by the input bisimilarity condition that $s_0 \nfareduces[\smash{b}]\asim q_0$.
  But $s_1$ is the unique $b$-successor of $s_0$, and so we may deduce that $s_1 \asim q_0$.
  Just as $s_1$ is a final state, the finality condition demands that $q_0$ be final, which it is not.
  From this contradiction, we conclude that $q_0$ and $s_0$ are \emph{not} bisimilar. 
\end{proof}

However, if both automata are \acp{DFA}, then language equivalence does imply bisimilarity.
%
\begin{theorem}
  Let $\aut{A}_1 = (Q_1, \dfanext_1, F_1)$ and $\aut{A}_2 = (Q_2, \dfanext_2, F_2)$ be \emph{\acp{DFA}} over an input alphabet $\ialph$.
  Then $\autlang{\aut{A}_1}{q} = \autlang{\aut{A}_2}{s}$ implies $q \asim s$.
\end{theorem}
%
\begin{proof}
  Let $\mathord{\simu{R}} = \Set{ (q, s) \given \autlang{\aut{A}_1}{q} = \autlang{\aut{A}_2}{s} }$; we will prove that $\simu{R}$ is a bisimulation between the \acp{DFA} $\aut{A}_1$ and $\aut{A}_2$.
  %
  \begin{description}[parsep=0pt, listparindent=\parindent]
  \item[Input bisimilarity]
    Assume that $s \simu{R}^{-1}\dfareduces[a] q'_a$; we must show that $s \dfareduces[a]\simu{R}^{-1} q'_a$.
    Because $\aut{A}_2$ is deterministic, it suffices to show that $\autlang{\aut{A}_1}{q'_a} = \autlang{\aut{A}_2}{s'_a}$, where $s'_a$ is the unique $a$-successor of $s$.

    Choose an arbitrary word $w$ from the language accepted from state $q'_a$.
    Then $a \wc w$ is in the language accepted from state $q$, and hence also in the language accepted from state $s$.
    Because $\aut{A}_2$ is deterministic, this can be only if $w$ is in the language accepted from state $s'_a$.
    Thus $\autlang{\aut{A}_1}{q'_a} \subseteq \autlang{\aut{A}_2}{s'_a}$.
    By symmetric reasoning, $\autlang{\aut{A}_1}{q'_a} \supseteq \autlang{\aut{A}_2}{s'_a}$.

  \item[Finality]
    Assume that $q \simu{R} s$; we must show that $q \in F_1$ if, and only if, $s \in F_2$.
    Because $\autlang{\aut{A}_1}{q} = \autlang{\aut{A}}{s}$, the states $q$ and $s$ either both accept or both reject $\emp$.
    A state accepts the empty word, $\emp$, exactly when it is a final state, so it follows that $q \in F_1$ if, and only if, $s \in F_2$.
  %
  \qedhere
  \end{description}
\end{proof}


% \subsection{\Aclp*{NFA} with $\emp$-transitions}

% \begin{definition}
%   \Iac{NFA} with $\emp$-moves over a finite alphabet $\ialph$ is a triple $\aut{A} = (Q, \mathord{\nfareduces}, F)$ consisting of:
%   \begin{itemize}
%   \item a finite set of \vocab{states}, $Q$;
%   \item a \vocab{transition relation}, $\mathord{\nfareduces} \subseteq (Q \times \ialph) \times Q$; and
%   \item a subset of \vocab{final states}, $F \subseteq Q$.
%   \end{itemize}
%   We will write $q \nfaReduces[a] q'$ whenever $q \nfareduces[\emp] \dotsb \nfareduces[\emp] \nfareduces[a] \nfareduces[\emp] \dotsb \nfareduces[\emp] q'$.

%   The transition relation can be lifted to one involving finite input words: For each input word $w = a_1 \wc a_2 \dotsm a_n$, let $q \nfaReduces[w] q'$ if $q = q_0 \nfaReduces[a_1] q_1 \nfaReduces[a_2] \dotsb \nfaReduces[a_n] q_n = q'$ for some sequence of states $q_0, q_1, \dotsc, q_n \in Q$.

%   The automaton $\aut{A}$ accepts input word $w$ from state $q$ if there exists a state $q' \in Q$ such that $q \nfaReduces[w] q' \in F$;
%   otherwise, the automaton rejects word $w$ from state $q$.
% \end{definition}

% \begin{marginfigure}
%   \begin{tikzcd}
%     \graph {
      
%   \end{tikzcd}
% \end{marginfigure}

\section{Finite transducers}
\fixnote{Remove these?}

\begin{definition}
  \Iac{SFT} over a finite input alphabet $\ialph$ and a finite output alphabet $\oalph$ is a tuple $\aut{T} = (Q, \sftnext, \sftout, \sftterm)$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$;
  \item a \vocab{transition function}, $\sftnext\colon Q \times \ialph \to Q$;
  \item a \vocab{output function}, $\sftout\colon Q \times \ialph \to \finwds{\oalph}$; and
  \item a \vocab{terminal output function}, $\sftterm\colon Q \to \finwds{\oalph}$.
  \end{itemize}

  Define a combined transition--output function $\mathord{\sftreduces}\colon Q \times \ialph \to \finwds{\oalph} \times Q$:
  \begin{equation*}
    q \sftreduces[\tio{a | v}] \sftnext(q, a) \text{, where $v = \sftout(q, a)$}
  \end{equation*}
  We then lift this function, defining a function $\mathord{\sftReducesEnd}\colon Q \times \finwds{\ialph} \to \finwds{\oalph}$ on finite input words: 
  For each input word $w = a_1 \wc a_2 \dotsm a_n$:
  \begin{gather*}
    q \sftReducesEnd[w] v
    \\ \text{if and only if} \\
    q \sftreduces[\tio{a_1 | v_1}] q_1 \sftreduces[\tio{a_2 | v_2}] \dotsb \sftreduces[\tio{a_n | v_n}] q_n
    \text{ and }
    v = (v_1 \wc v_2 \dotsm v_n) \wc* \sftterm(q_n)
    \mathrlap{\,.}
  \end{gather*}

  The \ac{SFT} $\aut{T}$ transforms, from state $q$, the input word $w$ into the output word $v$ if $(q, \emp) \sftReducesEnd[w] v$.
\end{definition}



\subsection{From \acp*{SFT} to proofs}

\begin{equation*}
  \begin{lgathered}
    \finwds{\ialph} \defd \plus*[sub=_{a \in \ialph}]{a\colon\finwds{\ialph}, \emp\colon \varepsilon} \\
    \finwds{\oalph} \defd \plus*[sub=_{a \in \oalph}]{a\colon\finwds{\oalph}, \emp\colon \varepsilon} \\
    \slof{\finwds{\ialph} |- \hat{q} : \finwds{\oalph}} \defd
      \caseL[a \in \ialph]{a => \spawn{\hat{q}'_a}{\selectR{\sftout}(q, a)} | \emp => \selectR{\sftterm}(q)}
  \end{lgathered}
\end{equation*}

\subsection{From proofs to \acp*{SFT}}

\begin{equation*}
  \begin{lgathered}
    \slof{\finwds{\ialph} |- p : \finwds{\oalph}}
      \defd \caseL[a \in \ialph]{a => \spawn{p'_a}{\selectR{v}_{p,a}} | \emp => \spawn{e_p}{\selectR{v}'_{p,a}}} \\
    \slof{\finwds{\ialph} |- p : \finwds{\oalph}}
      \defd \spawn{p'}{\selectR{v}_p} \\
    \slof{\finwds{\ialph} |- p : \varepsilon}
      \defd \dotso \\
    \slof{\varepsilon |- p : \finwds{\oalph}}
      \defd \dotso
  \end{lgathered}
\end{equation*}


\begin{marginfigure}
  \begin{gather*}
    \mathllap{\aut{T}_1 = {}}
    \begin{tikzpicture}[baseline=(q_0.base)]
      \graph [automaton] {
        q_0
         -> [loop above, "$\tio{a | a}$"]
        q_0;
      };
    \end{tikzpicture}
    \\
    \mathllap{\aut{T}_2 = {}}
    \begin{tikzpicture}[baseline=(s_0.base)]
      \graph [automaton] {
        s_0
         -> [bend left, "$\tio{a | \emp}$"]
        s_1
         -> [bend left, "$\tio{a | aa}$"]
        s_0;
      };
    \end{tikzpicture}
  \end{gather*}
  \caption{Two \acp{NFA} that copy streams of $a$s.}
\end{marginfigure}


% \section{\Aclp*{DPDA}}

% \begin{definition}
%   \Iac{DPDA} over a finite input alphabet $\ialph$ and a finite stack alphabet $\salph$ is a triple $\aut{A} = (Q, \mathord{\nfareduces}, F)$ consisting of:
%   \begin{itemize}
%   \item a finite set of \vocab{states}, $Q$;
%   \item a \vocab{transition relation} on state-stack pairs, $\mathord{\nfareduces} \subseteq (Q \times \finwds{\salph}) \times \augalph{\ialph}{\emp} \times (Q \times \finwds{\salph})$; and
%   \item a subset of \vocab{final states}, $F \subseteq Q$.
%   \end{itemize}

%   We will write $q \nfareduces[a] q'$ whenever $((q, a), q') \in \mathord{\nfareduces}$.

%   The transition relation can be lifted to one involving finite input words: For each word $w = \alpha_1 \wc \alpha_2 \dotsm \alpha_n \in \finwds{\ialph}$, let $q \nfareduces[w] q'$ if $q = q_0 \nfareduces[\alpha_1] q_1 \nfareduces[\alpha_2] \dotsb \nfareduces[\alpha_n] q_n = q'$ for some sequence of states $q_0, q_1, \dotsc, q_n \in Q$.

%   The \ac{DPDA} $\aut{A}$ accepts input word $w$ from state $q$ if there exists a state $q' \in Q$ such that $q \nfareduces[w] q' \in F$;
%   otherwise, the automaton rejects word $w$ from state $q$.
%   The language of all words accepted by automaton $\aut{A}$ from state $q$ is denoted $\autlang{\aut{A}}{q}$.%
%   \footnote{We sometimes omit the subscript if the automaton is clear from the context.}

%   $(q, s) = (q_0, s_0) \nfareduces[\alpha_1] (q_1, s_1) \nfareduces[\alpha_2] \dotsb \nfareduces[\alpha_n] (q', s')$ with $q' \in F$.
% \end{definition}


\section{Chains of communicating automata}
\fixnote{Remove these?}

\begin{definition}
  A \emph{chain of communicating automata} over a finite alphabet $\ialph$ is a tuple $\aut{C} = (Q, (\ialph_q)_{q \in Q}, (\oalph_q)_{q \in Q})$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$, that is partitioned into: left- and right-reading states, $\rL{Q}$ and $\rR{Q}$; left- and right-writing states, $\wL{Q}$ and $\wR{Q}$; forking states, $\fS{Q}$; and halting states, $\hS{Q}$;
  \item a state-indexed set of finite \vocab{left-hand alphabets}, $(\ialph_q)_{q \in Q}$, and a state-indexed set of finite \vocab{right-hand alphabets}, $(\oalph_q)_{q \in Q}$;
  \item $\rL{\delta} \colon \Pi q{:}\rL{Q}. \ialph_q \to Q$, with the condition that $\ialph_q = \ialph_{q'}$ and $\oalph_q = \oalph_{q'}$ for all $q' \in \cod{\rL{\delta}_q}$, and $\rR{\delta} \colon (\exists q{:}\rR{Q}. \oalph_q) \to Q$;
  \item $\wL{\delta} \colon \wL{Q} \to \exists q'{:}Q. \ialph_{q'}$ and $\wR{\delta} \colon \wR{Q} \to \exists q'{:}Q. \oalph_{q'}$; and
  \item $\fS{\delta} \colon \fS{Q} \to Q \times Q$.
  \end{itemize}

  \vocab{Chain configurations}, $c$ and $d$, consist of a finite sequence of states $q_1, q_2, \dotsc, q_n \in Q$ with, for all $1 \leq i < n$, a finite word drawn from $\finwds{\ialph_{q_{i+1}}}$ between neighboring states $q_i$ and $q_{i+1}$.
  In addition, a finite word drawn from $\finwds{\ialph_{q_1}}$ and a finite word drawn from $\finwds{\oalph_{q_n}}$ bracket the configuration.
  Formally, then, a chain configuration is a string drawn from the set
  \begin{equation*}
    \finwds{\ialph_{q_1}} q_1 \finwds{\ialph_{q_2}} q_2 \dotsm \finwds{\ialph_{q_n}} q_n \finwds{\oalph_{q_n}}
    \,,
  \end{equation*}
  for some finite sequence of states $q_1, q_2, \dotsc, q_n \in Q$.
  The chain configuration is \vocab{well-formed} if $\oalph_{q_i} = \ialph_{q_{i+1}}$ for all $1 \leq i < n$.

  \begin{itemize}
  \item $c \wc a \,q\, d \reduces c \,q'\, d$ if $\rL{\delta}_q(a) = q'$, and $c \,q\, a \wc d \reduces c \,q'\, d$ if $\rR{\delta}_q(a) = q'$;
  \item $c \,q\, d \reduces c \wc a \,q'\, d$ if $\wL{\delta}(q) = (q', a)$, and $c \,q\, d \reduces c \,q'\, a \wc d$ if $\wR{\delta}(q) = (q', a)$;

  \item $c \,q\, d \reduces c \, q' \, q'' \, d$ if $\fS{\delta}(q) = (q', q'')$;
  \item $c \,q\, d \reduces c \, d$ if $q \in \hS{Q}$ and $\ialph_q = \oalph_q$.
  \end{itemize}
\end{definition}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
