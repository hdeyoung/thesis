\chapter{Preliminaries: Automata}\label{ch:automata}

\section{Alphabets, words, and languages}

An alphabet $\ialph$ is simply a set of letters, $a \in \ialph$.
A finite word $w$ over the alphabet $\ialph$ is then a (possibly empty) finite sequence of letters drawn from $\ialph$;
we denote the empty word by $\emp$ and the set of all finite words over $\ialph$ by $\finwds{\ialph}$.
Finite words form a monoid under concatenation, with $\emp$ being the unit.

It is also possible to construct infinite words.
An infinite word over the alphabet $\ialph$ is a countably infinite sequence of letters drawn from $\ialph$;
we denote the set of all infinite words over $\ialph$ by $\infinwds{\ialph}$.
We also use $\wds{\ialph}$ to denote the set of all words -- finite or infinite -- over the alphabet $\ialph$; that is, $\wds{\ialph} = \finwds{\ialph} \union \infinwds{\ialph}$.

A language is a set of words.
Depending on the context, it will be a subset of either $\wds{\ialph}$, $\infinwds{\ialph}$, or $\finwds{\ialph}$.

It will sometimes be useful to work with an augmented alphabet.
Given a symbol $c \notin \ialph$, we may form the augmented alphabet $\augalph{\ialph}{c} = \ialph \union \{c\}$.
The augmented alphabet $\augalph{\ialph}{\emp}$ is the most

\subsection{Endmarked alphabets and words}

% An endmarked alphabet $\ealph{\ialph}$ is a pair $\ealph{\ialph} = (, )$ of finite alphabets $ $ and $ $.

\section{\Aclp*{NFA}}

\begin{definition}
  \Iac{NFA} over a finite alphabet $\ialph$ is a triple $\aut{A} = (Q, \mathord{\nfareduces}, F)$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$;
  \item a \vocab{transition relation}, $\mathord{\nfareduces} \subseteq (Q \times \ialph) \times Q$; and
  \item a subset of \vocab{final states}, $F \subseteq Q$.
  \end{itemize}
  We will write $q \nfareduces[a] q'$ whenever $((q, a), q') \in \mathord{\nfareduces}$.

  The transition relation can be lifted to one involving finite input words: For each word $w = a_1 \wc a_2 \dotsm a_n \in \finwds{\ialph}$, let $q \nfareduces[w] q'$ if $q = q_0 \nfareduces[a_1] q_1 \nfareduces[a_2] \dotsb \nfareduces[a_n] q_n = q'$ for some sequence of states $q_0, q_1, \dotsc, q_n \in Q$.

  The \ac{NFA} $\aut{A}$ accepts input word $w$ from state $q$ if there exists a state $q' \in Q$ such that $q \nfareduces[w] q' \in F$;
  otherwise, the automaton rejects word $w$ from state $q$.
  The language of all words accepted by automaton $\aut{A}$ from state $q$ is denoted $\autlang{\aut{A}}{q}$.%
  \footnote{We sometimes omit the subscript if the automaton is clear from the context.}
\end{definition}

Also, notice that, unlike most standard definitions of \acp{NFA}, this definition does not fix an initial state for the automaton.
This is because we will be primarily interested in the operational aspects of \iac{NFA}, rather than its linguistic aspects.

\begin{example}
  \begin{marginfigure}
    \begin{equation*}
      \mathllap{\aut{A}_1 = {}}
      \begin{tikzpicture}[baseline=(q_0.base)]
        \graph [automaton] {
          q_0
           -> [loop above, "a,b"]
          q_0
           -> ["b"]
          q_1 [accepting]
           -> ["a,b"]
          q_2
           -> [loop above, "a,b"]
          q_2;
        };
      \end{tikzpicture}
    \end{equation*}
    \caption{\Iac*{NFA} that accepts, from state $q_0$, exactly those words that end with $b$.}\label{fig:nfa-example-ends-b}
  \end{marginfigure}
  %
  As a concrete example, consider the \ac{NFA} $\aut{A}_1$ over the input alphabet $\ialph = \set{a, b}$ that is depicted in \cref{fig:nfa-example-ends-b}.
  This \ac{NFA} accepts, from state $q_0$, exactly those words that end with $b$.
  For comparison, the only word accepted from state $q_1$ is $\emp$.
  This \ac{NFA} is indeed nondeterministic, as both $q_0 \nfareduces[b] q_0$ and $q_0 \nfareduces[b] q_1$ hold.
\end{example}

\begin{definition}
  \Iacf{DFA} is \iac{NFA} whose transition relation is, more precisely, a function.
\end{definition}

\begin{example}
  \begin{marginfigure}
    \begin{equation*}
      \mathllap{\aut{A}_2 = {}}
      \begin{tikzpicture}[baseline=(s_0.base)]
        \graph [automaton] {
          s_0
           -> [loop above, "a"]
          s_0
           -> [bend left, "b"]
          s_1 [accepting]
           -> [loop above, "b"]
          s_1
           -> [bend left, "a"]
          s_0;
        };
      \end{tikzpicture}
    \end{equation*}
    \caption{\Iac*{DFA} that accepts, from state $s_0$, exactly those words that end with $b$.}\label{fig:dfa-example-ends-b}
  \end{marginfigure}
  \Cref{fig:dfa-example-ends-b} depicts \iac{DFA} over the input alphabet $\ialph = \set{a, b}$ that accepts, from state $s_0$, exactly those words that end with $b$.
  For comparison, the empty word $\emp$, too, is accepted from the state $s_1$.
\end{example}

\subsection{\acs*{NFA} bisimilarity}

\begin{definition}[\ac*{NFA} bisimilarity]
  Let $\aut{A} = (Q, \mathord{\nfareduces}, F)$ be \iac{NFA} over the input alphabet $\ialph$.
  An \emph{\acs{NFA} bisimulation} for $\aut{A}$ is a symmetric binary relation on states, $\mathord{\simu{R}} \subseteq Q \times Q$, that satisfies the following conditions.
  \begin{description}
  \item[Input bisimilarity]
    If $q \simu{R}\nfareduces[a] s'$, then $q \nfareduces[a]\simu{R} s'$.
  \item[Finality]
    If $q \simu{R} s \in F$, then $q \in F$.
  \end{description}
  \vocab{\ac{NFA} bisimilarity} for $\aut{A}$, $\asim_{\aut{A}}$, is the largest bisimulation for $\aut{A}$.
\end{definition}

Usually the automaton $\aut{A}$ is 

\begin{theorem}
  Bisimilarity is an equivalence relation.
\end{theorem}
%
\begin{proof}
  Bisimilarity can be proved to be reflexive by showing that the state equality relation is a bisimulation and therefore included in the largest bisimulation.
  Bisimilarity is symmetric by definition.
  Bisimilarity can be proved to be transitive by showing that the relation $\asim\asim$ is a bisimulation.
\end{proof}

\begin{theorem}
  Let $\aut{A} = (Q, \mathord{\nfareduces}, F)$ be \iac{NFA} over the input alphabet $\ialph$, and let $\simu{R}$ be a bisimulation for $\aut{A}$.
  Then $q \simu{R}\nfareduces[w] s'$ implies $q \nfareduces[w]\simu{R} s'$.
\end{theorem}
%
\begin{proof}
  By induction over the structure of word $w$.
\end{proof}

\begin{theorem}
  Let $\aut{A} = (Q, \mathord{\nfareduces}, F)$ be \iac{NFA} over the input alphabet $\ialph$.
  Then $q \asim s$ implies $\autlang{\aut{A}}{q} = \autlang{\aut{A}}{s}$.
\end{theorem}
%
\begin{proof}
  Because bisimilarity is symmetric, it suffices to show that $q \asim s$ implies $\autlang{\aut{A}}{q} \subseteq \autlang{\aut{A}}{s}$.
  Let $q$ and $s$ be bisimilar states, and choose an arbitrary word $w$ that is accepted from state $q$.
  By definition, $q \nfareduces[w] q'_w \in F$ for some state $q'_w$.
  It follows from \cref{??} and [...] that $s \nfareduces[w] s'_w \in F$, for some state $s'_w$.
\end{proof}

The converse is false.
%
\begin{falseclaim}
  Let $\aut{A} = (Q, \mathord{\nfareduces}, F)$ be \iac{NFA} over the input alphabet $\ialph$.
  If $\autlang{\aut{A}}{q} = \autlang{\aut{A}}{s}$, then $q \asim s$.
\end{falseclaim}
%
\begin{proof}[Counterexample]
  Construct the \ac{NFA} $\aut{A} = \aut{A}_1 \union \aut{A}_2$ from the \acp{NFA} given in \cref{fig:nfa-example-ends-b,fig:dfa-example-ends-b}.
  Although the languages accepted by states $q_0$ and $s_0$ are the same, the two states are \emph{not} bisimilar.

  For the sake of deriving a contradiction, assume that $q_0 \asim s_0$ and its symmetric reflection, $s_0 \asim q_0$.
  Because $q_0$ is one of the $b$-successors of $q_0$, it follows by the input bisimilarity condition that $s_0 \nfareduces[b]\asim q_0$.
  But $s_1$ is the unique $b$-successor of $s_0$, and so we may deduce that $s_1 \asim q_0$.
  Just as $s_1$ is a final state, the finality condition demands that $q_0$ be final, which it is not.
  From this contradiction, we conclude that $q_0$ and $s_0$ are \emph{not} bisimilar. 
\end{proof}


\subsection{\Aclp*{NFA} with $\emp$-transitions}

\begin{definition}
  \Iac{NFA} with $\emp$-moves over a finite alphabet $\ialph$ is a triple $\aut{A} = (Q, \mathord{\nfareduces}, F)$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$;
  \item a \vocab{transition relation}, $\mathord{\nfareduces} \subseteq (Q \times \ialph) \times Q$; and
  \item a subset of \vocab{final states}, $F \subseteq Q$.
  \end{itemize}
  We will write $q \nfaReduces[a] q'$ whenever $q \nfareduces[\emp] \dotsb \nfareduces[\emp] \nfareduces[a] \nfareduces[\emp] \dotsb \nfareduces[\emp] q'$.

  The transition relation can be lifted to one involving finite input words: For each input word $w = a_1 \wc a_2 \dotsm a_n$, let $q \nfaReduces[w] q'$ if $q = q_0 \nfaReduces[a_1] q_1 \nfaReduces[a_2] \dotsb \nfaReduces[a_n] q_n = q'$ for some sequence of states $q_0, q_1, \dotsc, q_n \in Q$.

  The automaton $\aut{A}$ accepts input word $w$ from state $q$ if there exists a state $q' \in Q$ such that $q \nfaReduces[w] q' \in F$;
  otherwise, the automaton rejects word $w$ from state $q$.
\end{definition}

% \begin{marginfigure}
%   \begin{tikzcd}
%     \graph {
      
%   \end{tikzcd}
% \end{marginfigure}

\section{Finite transducers}

\begin{definition}
  \Iac{SFT} over a finite input alphabet $\ialph$ and a finite output alphabet $\oalph$ is a tuple $\aut{T} = (Q, \sftnext, \sftout, \sftterm)$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$;
  \item a \vocab{transition function}, $\sftnext\colon Q \times \ialph \to Q$;
  \item a \vocab{output function}, $\sftout\colon Q \times \ialph \to \finwds{\oalph}$; and
  \item a \vocab{terminal output function}, $\sftterm\colon Q \to \finwds{\oalph}$.
  \end{itemize}

  Define a combined transition--output function $\mathord{\sftreduces}\colon Q \times \ialph \to \finwds{\oalph} \times Q$:
  \begin{equation*}
    q \sftreduces[\tio{a | v}] \sftnext(q, a) \text{, where $v = \sftout(q, a)$}
  \end{equation*}
  We then lift this function, defining a function $\mathord{\sftReducesEnd}\colon Q \times \finwds{\ialph} \to \finwds{\oalph}$ on finite input words: 
  For each input word $w = a_1 \wc a_2 \dotsm a_n$:
  \begin{gather*}
    q \sftReducesEnd[w] v
    \\ \text{if and only if} \\
    q \sftreduces[\tio{a_1 | v_1}] q_1 \sftreduces[\tio{a_2 | v_2}] \dotsb \sftreduces[\tio{a_n | v_n}] q_n
    \text{ and }
    v = (v_1 \wc v_2 \dotsm v_n) \wc* \sftterm(q_n)
    \mathrlap{\,.}
  \end{gather*}

  The \ac{SFT} $\aut{T}$ transforms, from state $q$, the input word $w$ into the output word $v$ if $(q, \emp) \sftReducesEnd[w] v$.
\end{definition}



\subsection{From \acp*{SFT} to proofs}

\begin{equation*}
  \begin{lgathered}
    \finwds{\ialph} \defd \plus*[sub=_{a \in \ialph}]{a\colon\finwds{\ialph}, \emp\colon \varepsilon} \\
    \finwds{\oalph} \defd \plus*[sub=_{a \in \oalph}]{a\colon\finwds{\oalph}, \emp\colon \varepsilon} \\
    \slof{\finwds{\ialph} |- \hat{q} : \finwds{\oalph}} \defd
      \caseL[a \in \ialph]{a => \spawn{\hat{q}'_a}{\selectR{\sftout}(q, a)} | \emp => \selectR{\sftterm}(q)}
  \end{lgathered}
\end{equation*}

\subsection{From proofs to \acp*{SFT}}

\begin{equation*}
  \begin{lgathered}
    \slof{\finwds{\ialph} |- p : \finwds{\oalph}}
      \defd \caseL[a \in \ialph]{a => \spawn{p'_a}{\selectR{v}_{p,a}} | \emp => \spawn{e_p}{\selectR{v}'_{p,a}}} \\
    \slof{\finwds{\ialph} |- p : \finwds{\oalph}}
      \defd \spawn{p'}{\selectR{v}_p} \\
    \slof{\finwds{\ialph} |- p : \varepsilon}
      \defd \dotso \\
    \slof{\varepsilon |- p : \finwds{\oalph}}
      \defd \dotso
  \end{lgathered}
\end{equation*}


\begin{marginfigure}
  \begin{gather*}
    \mathllap{\aut{T}_1 = {}}
    \begin{tikzpicture}[baseline=(q_0.base)]
      \graph [automaton] {
        q_0
         -> [loop above, "$\tio{a | a}$"]
        q_0;
      };
    \end{tikzpicture}
    \\
    \mathllap{\aut{T}_2 = {}}
    \begin{tikzpicture}[baseline=(s_0.base)]
      \graph [automaton] {
        s_0
         -> [bend left, "$\tio{a | \emp}$"]
        s_1
         -> [bend left, "$\tio{a | aa}$"]
        s_0;
      };
    \end{tikzpicture}
  \end{gather*}
  \caption{Two \acp{NFA} that copy streams of $a$s.}
\end{marginfigure}


\section{\Aclp*{DPDA}}

\begin{definition}
  \Iac{DPDA} over a finite input alphabet $\ialph$ and a finite stack alphabet $\salph$ is a triple $\aut{A} = (Q, \mathord{\nfareduces}, F)$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$;
  \item a \vocab{transition relation} on state-stack pairs, $\mathord{\nfareduces} \subseteq (Q \times \finwds{\salph}) \times \augalph{\ialph}{\emp} \times (Q \times \finwds{\salph})$; and
  \item a subset of \vocab{final states}, $F \subseteq Q$.
  \end{itemize}

  We will write $q \nfareduces[a] q'$ whenever $((q, a), q') \in \mathord{\nfareduces}$.

  The transition relation can be lifted to one involving finite input words: For each word $w = \alpha_1 \wc \alpha_2 \dotsm \alpha_n \in \finwds{\ialph}$, let $q \nfareduces[w] q'$ if $q = q_0 \nfareduces[\alpha_1] q_1 \nfareduces[\alpha_2] \dotsb \nfareduces[\alpha_n] q_n = q'$ for some sequence of states $q_0, q_1, \dotsc, q_n \in Q$.

  The \ac{DPDA} $\aut{A}$ accepts input word $w$ from state $q$ if there exists a state $q' \in Q$ such that $q \nfareduces[w] q' \in F$;
  otherwise, the automaton rejects word $w$ from state $q$.
  The language of all words accepted by automaton $\aut{A}$ from state $q$ is denoted $\autlang{\aut{A}}{q}$.%
  \footnote{We sometimes omit the subscript if the automaton is clear from the context.}

  $(q, s) = (q_0, s_0) \nfareduces[\alpha_1] (q_1, s_1) \nfareduces[\alpha_2] \dotsb \nfareduces[\alpha_n] (q', s')$ with $q' \in F$.
\end{definition}


\section{Chains of communicating automata}

\begin{definition}
  A \emph{chain of communicating automata} over a finite alphabet $\ialph$ is a tuple $\aut{C} = (Q, (\ialph_q)_{q \in Q}, (\oalph_q)_{q \in Q})$ consisting of:
  \begin{itemize}
  \item a finite set of \vocab{states}, $Q$, that is partitioned into: left- and right-reading states, $\rL{Q}$ and $\rR{Q}$; left- and right-writing states, $\wL{Q}$ and $\wR{Q}$; forking states, $\fS{Q}$; and halting states, $\hS{Q}$;
  \item a state-indexed set of finite \vocab{left-hand alphabets}, $(\ialph_q)_{q \in Q}$, and a state-indexed set of finite \vocab{right-hand alphabets}, $(\oalph_q)_{q \in Q}$;
  \item $\rL{\delta} \colon \Pi q{:}\rL{Q}. \ialph_q \to Q$, with the condition that $\ialph_q = \ialph_{q'}$ and $\oalph_q = \oalph_{q'}$ for all $q' \in \cod{\rL{\delta}_q}$, and $\rR{\delta} \colon (\exists q{:}\rR{Q}. \oalph_q) \to Q$;
  \item $\wL{\delta} \colon \wL{Q} \to \exists q'{:}Q. \ialph_{q'}$ and $\wR{\delta} \colon \wR{Q} \to \exists q'{:}Q. \oalph_{q'}$; and
  \item $\fS{\delta} \colon \fS{Q} \to Q \times Q$.
  \end{itemize}

  \vocab{Chain configurations}, $c$ and $d$, consist of a finite sequence of states $q_1, q_2, \dotsc, q_n \in Q$ with, for all $1 \leq i < n$, a finite word drawn from $\finwds{\ialph_{q_{i+1}}}$ between neighboring states $q_i$ and $q_{i+1}$.
  In addition, a finite word drawn from $\finwds{\ialph_{q_1}}$ and a finite word drawn from $\finwds{\oalph_{q_n}}$ bracket the configuration.
  Formally, then, a chain configuration is a string drawn from the set
  \begin{equation*}
    \finwds{\ialph_{q_1}} q_1 \finwds{\ialph_{q_2}} q_2 \dotsm \finwds{\ialph_{q_n}} q_n \finwds{\oalph_{q_n}}
    \,,
  \end{equation*}
  for some finite sequence of states $q_1, q_2, \dotsc, q_n \in Q$.
  The chain configuration is \vocab{well-formed} if $\oalph_{q_i} = \ialph_{q_{i+1}}$ for all $1 \leq i < n$.

  \begin{itemize}
  \item $c \wc a \,q\, d \reduces c \,q'\, d$ if $\rL{\delta}_q(a) = q'$, and $c \,q\, a \wc d \reduces c \,q'\, d$ if $\rR{\delta}_q(a) = q'$;
  \item $c \,q\, d \reduces c \wc a \,q'\, d$ if $\wL{\delta}(q) = (q', a)$, and $c \,q\, d \reduces c \,q'\, a \wc d$ if $\wR{\delta}(q) = (q', a)$;

  \item $c \,q\, d \reduces c \, q' \, q'' \, d$ if $\fS{\delta}(q) = (q', q'')$;
  \item $c \,q\, d \reduces c \, d$ if $q \in \hS{Q}$ and $\ialph_q = \oalph_q$.
  \end{itemize}
\end{definition}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
