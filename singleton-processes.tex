\chapter{Session-typed processes}\label{ch:singleton-processes}

\begin{itemize}
\item Connections to SILL
\end{itemize}

\section{Session-typed processes: A Curry--Howard interpretation of singleton logic}

\begin{syntax*}
  Session types &
    A & \alpha \mid \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \mid \with*[sub=_{\ell \in L}]{\ell:A_{\ell}}
  \\
  Process terms &
    P,Q & \spawn{P}{Q} \mid \fwd
            \begin{array}[t]{@{{} \mid {}}l@{}}
              \selectR{\kay} \mid \caseL[\ell \in L]{\ell => Q_{\ell}} \\
              \caseR[\ell \in L]{\ell => P_{\ell}} \mid \selectL{\kay}
            \end{array}
\end{syntax*}

\begin{inferences}
  \infer[\jrule{CUT}^B]{\slof{A |- \spawn{P}{Q} : C}}{
    \slof{A |- P : B} & \slof{B |- Q : C}}
  \and
  \infer[\jrule{ID}^A]{\slof{A |- \fwd : A}}{}
  \\
  \infer[\rrule{\plus}]{\slof{A_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}}}{
    \text{($\kay \in L$)}}
  \and
  \infer[\lrule{\plus}]{\slof{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} |- \caseL[\ell \in L]{\ell => Q_{\ell}} : C}}{
    \multipremise{\ell \in L}{\slof{A_{\ell} |- Q_{\ell} : C}}}
  \\
  \infer[\rrule{\with}]{\slof{A |- \caseR[\ell \in L]{\ell => P_{\ell}} : \with*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
    \multipremise{\ell \in L}{\slof{A |- P_{\ell} : B_{\ell}}}}
  \and
  \infer[\lrule{\with}]{\slof{\with*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- \selectL{\kay} : B_{\kay}}}{
    \text{($\kay \in L$)}}
\end{inferences}

\subsection{Cut reduction}

\begin{gather*}
  \infer[\jrule{CUT}]{\slof{A_{\kay} |- \spawn{\selectR{\kay}}{\caseL[\ell \in L]{\ell => Q_{\ell}}} : C}}{
  \infer[\rrule{\plus}]{\slof{A_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}}}{
    \text{($\kay \in L$)}} &
  \infer[\lrule{\plus}]{\slof{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} |- \caseL[\ell \in L]{\ell => Q_{\ell}} : C}}{
    \multipremise{\ell \in L}{\slof{A_{\ell} |- Q_{\ell} : C}}}}
  \\
  \cutreduces
  \\
  \slof{A_{\kay} |- Q_{\kay} : C}
\end{gather*}

Discussion of cut reduction vs.\ admissibility

\subsection{An inductive characterization of irreducible cuts}

% \begin{equation*}
%   \infer[\jrule{CUT}^{C_{\kay}}]{\slof{A |- \spawn{P}{\selectR{\kay}} : \plus*[sub=_{\ell \in L}]{\ell:C_{\ell}}}}{
%     \slof{A |- P : C_{\kay}} &
%     \infer[\rrule{\plus}]{\slof{C_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:C_{\ell}}}}{
%       \text{($\kay \in L$)}}}
% \end{equation*}
% Here $P$ cannot have left input or internal transitions, otherwise $\spawn{P}{\selectR{\kay}}$ will reduce.

% \begin{equation*}
%   \infer[\jrule{CUT}^{\plus*[sub=_{\ell \in L}]{\scriptstyle\ell:B_{\ell}}}]{\slof{A |- \spawn{P}{\caseL[\ell \in L]{\ell => Q_{\ell}}} : C}}{
%     \slof{A |- P : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}} &
%     \infer[\lrule{\plus}]{\slof{\plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- \caseL[\ell \in L]{\ell => Q_{\ell}} : C}}{
%       \multipremise{\ell \in L}{\slof{B_{\ell} |- Q_{\ell} : C}}}}
% \end{equation*}
% Here $P$ cannot have right output, left input, or internal transitions, otherwise $\spawn{P}{\caseL[\ell \in L]{\ell => Q_{\ell}}}$ will reduce.

% \begin{equation*}
%   \infer[\jrule{CUT}^{\with*[sub=_{\ell \in L}]{\scriptstyle\ell:B_{\ell}}}]{\slof{A |- \spawn{P}{\selectL{\kay}} : B_{\kay}}}{
%     \slof{A |- P : \with*[sub=_{\ell \in L}]{\ell:B_{\ell}}} &
%     \infer[\lrule{\with}]{\slof{\with*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- \selectL{\kay} : B_{\kay}}}{
%       \text{($\kay \in L$)}}}
% \end{equation*}
% Here $P$ cannot have right input, left input, or internal transitions, otherwise $\spawn{P}{\selectR{\kay}}$ will reduce.

\begin{equation*}
  \infer[\jrule{CUT}^{B_1}]{\slof{A |- \spawn{P}{(\spawn{Q_1}{Q_2})} : C}}{
    \slof{A |- P : B_1} &
    \infer[\jrule{CUT}^{B_2}]{\slof{B_1 |- \spawn{Q_1}{Q_2} : C}}{
      \slof{B_1 |- Q_1 : B_2} & \slof{B_2 |- Q_2 : C}}}
  \equiv
  \infer[\jrule{CUT}^{B_2}]{\slof{A |- \spawn{(\spawn{P}{Q_1})}{Q_2} : C}}{
    \infer[\jrule{CUT}^{B_1}]{\slof{A |- \spawn{P}{Q_1} : B_2}}{
      \slof{A |- P : B_1} & \slof{B_1 |- Q_1 : B_2}} &
    \slof{B_2 |- Q_2 : C}}
\end{equation*}

Values are intuitively easy to describe, at least up to cut-cut commuting conversions.
\begin{syntax*}
  Q{}ueues & Q & \selectL{\kay} \mid \selectR{\kay} \mid \spawn{\selectL{\kay}}{Q} \mid \spawn{Q}{\selectR{\kay}} \\
  Right values & R & \caseR[\ell \in L]{\ell => P_{\ell}} \mid \spawn{R}{\selectR{\kay}} \\
   Left values & L & \caseL[\ell \in L]{\ell => P_{\ell}} \mid \spawn{\selectL{\kay}}{L} \\
        Values & \mathrlap{V}\enspace\; & R \mid L \mid Q \mid \fwd
\end{syntax*}
We could use judgments $\mathsf{queue}$, $\mathsf{rvalue}$, $\mathsf{lvalue}$, and $\mathsf{value}$ for these syntactic categories.

\begin{theorem}
  If $\slof{A |- P : C}$, then $P \equiv\reduces$ or $P \equiv\mathrel{\mathsf{value}}$.
\end{theorem}
\begin{proof}
  All processes other than spawns are values, so we need only consider in detail the case of a spawn process.
  \begin{equation*}
    \infer[\jrule{CUT}^B]{\slof{A |- \spawn{P_1}{P_2} : C}}{
      \slof{A |- P_1 : B} & \slof{B |- P_2 : C}}
  \end{equation*}
  By the inductive hypothesis on the two subderivations: $P_1\;\mathsf{value}$ or $P_1 \equiv\reduces P'_1$ for some $P'_1$; and also $P_2\;\mathsf{value}$ or $P_2 \equiv\reduces P'_2$ for some $P'_2$.
  \begin{itemize}
  \item If $P_1 \equiv\reduces P'_1$, then $\spawn{P_1}{P_2} \equiv\reduces \spawn{P'_1}{P_2}$.
    Similarly, if $P_2 \equiv\reduces P'_2$, then $\spawn{P_1}{P_2} \equiv\reduces \spawn{P_1}{P'_2}$.
  \item Otherwise, $P_1\;\mathsf{value}$ and $P_2\;\mathsf{value}$.
    \begin{itemize}
    \item If $P_i \equiv \fwd$, then $\spawn{P_1}{P_2} \equiv\reduces P_{3-i}$.
    \item If $P_1 \equiv L_1\;\mathsf{lvalue}$ for some $L_1$, then either $P_1 \equiv \spawn{Q_1}{\caseL[\ell \in L]{\ell => P^1_{\ell}}}$ for some queue $Q_1$ and processes $(P^1_{\ell})_{\ell \in L}$, or $P_1 \equiv \caseL[\ell \in L]{\ell => P^1_{\ell}}$ for some processes $(P^1_{\ell})_{\ell \in L}$.
      It follows that
      \begin{gather*}
        \spawn{P_1}{P_2} \equiv \spawn{Q_1}{(\spawn{\caseL[\ell \in L]{\ell => P^1_{\ell}}}{P_2})} \reduces \spawn{Q_1}{\caseL[\ell \in L]{\ell => \spawn{P^1_{\ell}}{P_2}}}
        \\\text{or}\\
        \spawn{P_1}{P_2} \equiv \spawn{\caseL[\ell \in L]{\ell => P^1_{\ell}}}{P_2} \reduces \caseL[\ell \in L]{\ell => \spawn{P^1_{\ell}}{P_2}} \mathrlap{\,.}
      \end{gather*}
      The case in which $P_2 \equiv R_2\;\mathsf{rvalue}$ for some $R_2$ is symmetric.
    \item If $P_1 \equiv Q_1\;\mathsf{queue}$ for some $Q_1$, there are two subcases according to whether $Q_1$ contains a right-directed message.
      \begin{itemize}
      \item Consider the subcase in which $Q_1$ contains no right-directed message.
        If $P_2 \equiv Q_2\;\mathsf{queue}$ for some $Q_2$, then $\spawn{P_1}{P_2} \equiv \spawn{Q_1}{Q_2} \equiv\mathrel{\mathsf{queue}}$.
        Otherwise, if $P_2 \equiv L_2\;\mathsf{lvalue}$ for some $L_2$, then $\spawn{P_1}{P_2} \equiv \spawn{Q_1}{L_2} \equiv\mathrel{\mathsf{lvalue}}$.
      \item Consider the subcase in which $Q_1$ contains a right-directed message.
        If $P_2 \equiv Q_2\;\mathsf{queue}$ for some $Q_2$, then $Q_2$ must contain no left-directed message, for $\spawn{P_1}{P_2} \equiv \spawn{Q_1}{Q_2}$ would otherwise be ill-typed.
        It follows that $\spawn{P_1}{P_2} \equiv \spawn{Q_1}{Q_2} \equiv\mathrel{\mathsf{queue}}$.

        On the other hand, if $P_2 \equiv L_2\;\mathsf{lvalue}$, then either $L_2 \equiv \spawn{Q_2}{\caseL[\ell \in L]{\ell => P^2_{\ell}}}$ for some queue $Q_2$ and processes $(P^2_{\ell})_{\ell \in L}$, or $L_2 \equiv \caseL[\ell \in L]{\ell => P^2_{\ell}}$ for some processes $(P^2_{\ell})_{\ell \in L}$.
        It follows that $\spawn{Q_1}{Q_2} \equiv \spawn{Q'}{\selectR{\kay}}\;\mathsf{queue}$ for some $Q'$.
        And so 
        \begin{equation*}
          \spawn{P_1}{P_2} \equiv \spawn{Q'}{(\spawn{\selectR{\kay}}{\caseL[\ell \in L]{\ell => P^2_{\ell}}})} \reduces \spawn{Q'}{P^2_{\kay}}
        \end{equation*}
      \end{itemize}
      The case in which $P_2 \equiv Q_2\;\mathsf{queue}$ is symmetric.
    \item If $P_1 \equiv R_1\;\mathsf{rvalue}$ for some $R_1$ and $P_2 \equiv L_2\;\mathsf{lvalue}$, then only two of the possibilities are well-typed.
      \begin{itemize}
      \item Consider the subcase in which $R_1 = \spawn{R'_1}{\selectR{\kay}}$ and $L_2 = \caseL[\ell \in L]{\ell => P^2_{\ell}}$.
        It follows that 
        \begin{equation*}
          \spawn{P_1}{P_2} \equiv \spawn{(\spawn{R'_1}{\selectR{\kay}})}{\caseL[\ell \in L]{\ell => P^2_{\ell}}} \reduces \spawn{R'_1}{P^2_{\kay}} \mathrlap{\,.}
        \end{equation*}
      \item The subcase in which $R_1 = \caseR[\ell \in L]{\ell => P^1_{\ell}}$ and $L_2 = \spawn{\selectL{\kay}}{L'_2}$ is symmetric.
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{proof}

Getting these grammars to account for cut-cut commuting conversions is a bit trickier. 
%  
% \begin{syntax*}
%   Q{}ueues & Q^{\plus} & \selectR{\kay} \mid \spawn{Q^{\plus}_1}{Q^{\plus}_2} \\
%          & Q^{\with} & \selectL{\kay} \mid \spawn{Q^{\with}_1}{Q^{\with}_2} \\
%   Right values & R & \caseR[\ell \in L]{\ell => P_{\ell}} \mid Q^{\with} \mid \spawn{R}{Q^{\plus}} \\
%   Left values & L & \caseL[\ell \in L]{\ell => P_{\ell}} \mid Q^{\plus} \mid \spawn{Q^{\with}}{L} \\
%   Values & V & R \mid L \mid \fwd
% \end{syntax*}
% 
% \begin{falseclaim*}
%   If $\slof{A |- P : C}$ and $P \longarrownot\reduces$, then $P$ is a value.
% \end{falseclaim*}
% \begin{proof}[Counterexample]
%   Consider the typable, irreducible process
%   $\spawn{\selectL{1}}
%          {(\spawn{(\spawn{\selectL{3}}{\selectR{4}})}
%                  {\selectR{2}})}$.
%   This process is incorrectly not classified as a value.
% 
%   The top-level cut must arise from $\spawn{Q^{\with}}{L}$; it cannot arise from the other productions because $\spawn{(\spawn{\selectL{3}}{\selectR{4}})}{\selectR{2}}$ is neither fully right- or left-directed.
%   Because $\spawn{(\spawn{\selectL{3}}{\selectR{4}})}{\selectR{2}}$ is a left value, its top-level cut can only arise from $\spawn{Q^{\with}}{L}$.
%   So $\spawn{\selectL{3}}{\selectR{4}}$ arises from $Q^{\with}$.
%   That is impossible, however.
% \end{proof}
% 
We could revise the grammars to the following.
\begin{syntax*}
  Q{}ueues & Q^{\plus} & \selectR{\kay} \mid \spawn{Q^{\plus}_1}{Q^{\plus}_2} \\
           & Q^{\with} & \selectL{\kay} \mid \spawn{Q^{\with}_1}{Q^{\with}_2} \\
           & Q         & Q^{\with} \mid Q^{\plus} \mid \spawn{Q_1}{Q^{\plus}_2} \mid \spawn{Q^{\with}_1}{Q_2} \\
  Right values & R & \caseR[\ell \in L]{\ell => P_{\ell}} \mid \spawn{R}{Q^{\plus}} \\
   Left values & L & \caseL[\ell \in L]{\ell => P_{\ell}} \mid \spawn{Q^{\with}}{L} \\
        Values & \mathrlap{V}\enspace\; & R \mid L \mid Q \mid \fwd
\end{syntax*}

\begin{conjecture}\leavevmode
  \begin{itemize}[nosep]
  \item $V \longarrownot\reduces$ for all values $V$.
  \item For all right values $R$, the following hold:
    \begin{enumerate*}[label=\emph{(\roman*)}]
    \item $R \longarrownot\reduces$;
    \item $R \neq \caseL[\ell \in L]{\ell => P_{\ell}}$; and
    \item $R \neq \fwd$.
    \end{enumerate*}
  \item For all left values $L$, the following hold:
    \begin{enumerate*}[label=\emph{(\roman*)}]
    \item $L \longarrownot\reduces$;
    \item $L \neq \caseR[\ell \in L]{\ell => P_{\ell}}$; and
    \item $L \neq \fwd$.
    \end{enumerate*}
  \item For all queues $Q$, the following hold:
    \begin{enumerate*}[label=\emph{(\roman*)}]
    \item $Q \longarrownot\reduces$;
    \item $Q \neq \caseR[\ell \in L]{\ell => P_{\ell}}$;
    \item $Q \neq \caseL[\ell \in L]{\ell => P_{\ell}}$; and
    \item $Q \neq \fwd$.
    \end{enumerate*}
  \end{itemize}
\end{conjecture}
\begin{proof}
  By structural induction on the given process.

  A cut, $\spawn{P}{Q}$, is the only form of process that may reduce, and it reduces only if one of the following conditions is met:
  \begin{itemize}
  \item $P \reduces$ or $Q \reduces$;
  \item $P =\fwd$ or $Q=\fwd$:
  \item $P = \caseL[\ell \in L]{\ell => P_{\ell}}$ or $Q = \caseR[\ell \in L]{\ell => Q_{\ell}}$;
  \item $P \equiv \spawn{P_0}{\caseR[\ell \in L]{\ell => P_{\ell}}}$ and $Q \equiv \spawn{\selectL{\kay}}{Q_0}$: or
  \item $P \equiv \spawn{P_0}{\selectR{\kay}}$ and $Q \equiv \spawn{\caseL[\ell \in L]{\ell => Q_{\ell}}}{Q_0}$.
  \end{itemize}
\end{proof}

\subsection{Isomorphism}

\begin{syntax*}
  Q{}ueues & Q^{\plus} & \selectR{\kay} \mid \spawn{Q^{\plus}_1}{Q^{\plus}_2} \\
           & Q^{\with} & \selectL{\kay} \mid \spawn{Q^{\with}_1}{Q^{\with}_2} \\
           & Q         & Q^{\with} \mid Q^{\plus} \mid \spawn{Q_1}{Q^{\plus}_2} \mid \spawn{Q^{\with}_1}{Q_2} \\
  Right values & R & \caseR[\ell \in L]{\ell => P_{\ell}} \mid \spawn{R}{Q^{\plus}} \\
   Left values & L & \caseL[\ell \in L]{\ell => P_{\ell}} \mid \spawn{Q^{\with}}{L} \\
        Values & \mathrlap{V}\enspace\; & R \mid L \mid Q \mid \fwd
\end{syntax*}

\begin{equation*}
  \begin{lgathered}
    \finwds{\ialph} \defd \plus*[sub=_{a \in \ialph}]{a:\finwds{\ialph}, \emp:\varepsilon} \\
    \finwds{\oalph} \defd \plus*[sub=_{b \in \oalph}]{b:\finwds{\oalph}, \emp:\varepsilon} \\
    \slof{\finwds{\ialph} |- q : \finwds{\oalph}}
      \defd \caseL[a \in \ialph]{a => q'_a | \emp => \spawn{f_q}{Q^{\plus}}} \\
    \slof{\finwds{\ialph} |- q : \finwds{\oalph}}
      \defd 
  \end{lgathered}
\end{equation*}

\subsection{An operational semantics}

\begin{syntax*}
  Configurations &
    \cnf & \cnfe \mid (\cnf_1 \cc \cnf_2) \mid P
\end{syntax*}

\begin{inferences}
  \infer[\jrule{CUT}^B]{\slcof{A |- \cnf_1 \cc \cnf_2 : C}}{
    \slcof{A |- \cnf_1 : B} & \slcof{B |- \cnf_2 : C}}
  \and
  \infer[\jrule{ID}^A]{\slcof{A |- \cnfe : A}}{}
  \and
  \infer[\jrule{PROC}]{\slcof{A |- P : B}}{
    \slof{A |- P : B}}
\end{inferences}

\begin{inferences}
  \infer{\spawn{P}{Q} \reduces P \cc Q}{}
  \and
  \infer{\fwd \reduces \cnfe}{}
  \\
  \infer{\selectR{\kay} \cc \caseL[\ell \in L]{\ell => Q_{\ell}} \reduces Q_{\kay}}{}
  \and
  \infer{\caseR[\ell \in L]{\ell => P_{\ell}} \cc \selectL{\kay} \reduces P_{\kay}}{}
\end{inferences}

\begin{itemize}
\item SSOS is an ordered rewriting specification.  (How does this work with definitions?)
\end{itemize}

\begin{equation*}
  \begin{lgathered}
    \proc{\spawn{P}{Q}} \defd \proc{P} \fuse \proc{Q} \\
    \proc{\fwd} \defd \one \\
    \proc{\caseL[\ell \in L]{\ell => Q_{\ell}}} \defd \bigwith_{\ell \in L}\bigl(\proc{\selectR{\ell}} \limp \proc{Q_{\ell}}\bigr) \\
    \proc{\caseR[\ell \in L]{\ell => P_{\ell}}} \defd \bigwith_{\ell \in L}\bigl(\proc{P_{\ell}} \pmir \proc{\selectL{\ell}}\bigr)
  \end{lgathered}
\end{equation*}

\paragraph{Hypersequent}



\subsection{Example: Binary counter}

\begin{equation*}
  \proc{b_1} \defd (\msgL{i} \fuse \proc{b_0} \pmir \msgL{i}) \with (\proc{b_0} \fuse \msgR{s} \pmir \msgL{d})
\end{equation*}

\subsection{Example: \Aclp*{DFA}}

Contrast with inability to express \acp{NFA} (languages vs.\ operational semantics)

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
