\chapter{Singleton logic}\label{ch:singleton-logic}

Intuitionistic sequents are typically asymmetric.
In an intuitionistic sequent $\Gamma \vdash A$, there are finitely many antecedents, all collected into the context $\Gamma$, yet there is only a single consequent, $A$.%
\footnote{Or, at most one consequent if multiplicative falsehood is included\parencref[see, for example,]{sec:ordered-logic:mult-falsehood}.}
We might naturally wonder if a greater degree of symmetry can be brought to sequents.
Of course, classical sequents in calculi such as Gentzen's LK\autocite{Gentzen:??} enjoy a pleasant symmetry, but does there exist an \emph{intuitionistic} logic whose sequent calculus presentation uses symmetric sequents?

One approach might be to permit finitely many consequents, as in multiple-conclusion sequent calculi for intuitionistic logic\autocite{??}, but \textcite{Steinberger:JPL11} raises troubling concerns about meaning-theoretic explanations of such calculi.
So in this \lcnamecref{ch:singleton-logic}, we will instead follow a dual path to symmetry and examine a restriction in which sequents have exactly one antecedent -- no more and no less.
We call this requirement the \emph{single-antecedent restriction} and the logic to which it leads \emph{singleton logic}.
That such a drastic restriction on the structure of sequents yields a well-defined, computationally useful logic is rather surprising.

\newthought{Aside from} motivations of symmetry, the single-antecedent restriction is sensible within each branch of the computational trinity\autocite{Harper:??} -- proof theory, category theory, and type theory -- as we discuss in \cref{sec:singleton-logic:restriction}.
This \lcnamecref{ch:singleton-logic} is primarily devoted to the proof-theoretic consequences of the single-antecedent restriction, so the operational aspects are mostly postponed to \cref{ch:singleton-processes}.

\Cref{sec:singleton-logic:seq-calc} derives a sequent calculus presentation of singleton logic by a systematic application of the single-antecedent restriction to intuitionistic ordered logic's sequent calculus.
\Cref{sec:singleton-logic:seq-calc:metatheory} then establishes the basic metatheory of singleton logic's sequent calculus: identity expansion and, more importantly to our purposes, admissibility of cut.

But there are other presentations of logics besides sequent calculi, such as natural deduction and Hilbert systems.
So in \cref{sec:singleton-logic:hilbert}, a Hilbert system for singleton logic is considered.
The single-antecedent restriction necessarily precludes a true Hilbert system, but we ... a Hilbert-like system that may also be viewed as a variant of the sequent calculus.
\Cref{sec:singleton-logic:hilbert:metatheory} establishes the admissibility of a modus ponens-like rule, and contrasts the proof with that of admissibility of cut from \cref{sec:singleton-logic:metatheory}.

Finally, \cref{sec:singleton-logic:subsingleton} briefly overviews several possible extensions to singleton logic.



Intuitionistic sequents often contain
\begin{description}
\item[Proof-theoretical]
  Under the single-antecedent restriction, sequents enjoy an elegant symmetry -- exactly one consequent and now exactly one antecedent -- $\slseq{A |- B}$ rather than $\oseq{\octx |- B}$.
\item[Categorical]
\item[Operational] 
\end{description}
That such a drastic restriction on the structure of sequents yields a well-defined, computationally useful logic is rather surprising.

Recall from \cref{ch:ordered-logic} that the sequents of intuitionistic ordered logic are inherently asymmetric.
In an ordered sequent such as $\oseq{\octx |- A}$, there are finitely many antecedents, all collected into the context $\octx$, yet there is only a single consequent.%
\footnote{Or, at most one consequent if multiplicative falsehood is included\parencref[see]{sec:ordered-logic:mult-falsehood}.}
We might naturally wonder if a greater degree of symmetry can be brought to these ordered sequents.
Does there exist a related logic whose sequent calculus presentation uses symmetric sequents?

To achieve greater symmetry, intuitionism could, of course, be abandoned in favor of a classical noncommutative logic~\autocite{Abrusci:JSL91}.
One alternative that maintains an intuitionistic character might be to permit finitely many consequents, in a vein similar to multiple-conclusion sequent calculi for intuitionistic logic\autocite{??}.%
\footnote{However, \textcite{Steinberger:JPL11} raises troubling concerns about meaning-theoretic explanations of such calculi.}

However, in this \lcnamecref{ch:singleton-logic}, we will instead follow a dual path to symmetry and examine a fragment of intuitionistic ordered logic that is obtained by requiring sequents to have exactly one antecedent -- no more and no less.
We call this requirement the \emph{single-antecedent restriction} and the logical fragment to which it leads \emph{singleton logic}.
That such a drastic restriction on the structure of sequents yields a well-defined, computationally useful logic is rather surprising.

We will begin our examination of singleton logic in \cref{sec:singleton-logic:derive} by deriving its sequent calculus from that of intuitionistic ordered logic by a systematic application of the single-antecedent restriction.
\Cref{sec:singleton-logic:seq-calc} then establishes the basic metatheory of singleton logic's sequent calculus: identity expansion and, more importantly, admissibility of cut.

By analogy with a Curry--Howard interpretation of intuitionistic linear logic\autocite{Toninho:?}, we will argue in \cref{sec:singleton-logic:?} that the proof of admissibility of cut describes inherently synchronous interactions between proofs.
Such a calculus is not well-suited to the remainder of ...

So, in \cref{sec:singleton-logic:async-seq-calc}, we develop a novel form of sequent calculus and accompanying proof of admissibility of cut that describes inherently asynchronous interactions between proofs.

A discussion of singleton logic's computational model\alertinline{interpretation?} is postponed to the following \lcnamecref{ch:singleton-processes}.
In this \lcnamecref{ch:singleton-logic}, we confine our attention to the proof-theoretic aspects of singleton logic.


%  and require exactly one antecedent.

%  we present one such logic, \emph{singleton logic}.
% As its name suggests, singleton logic is the fragment of ordered logic obtained by requiring sequents to have exactly one antecedent -- no more and no less.
% That such a drastic restriction on the structure of contexts yields a well-defined, computationally useful logic is somewhat surprising.

% A discussion of singleton logic's isomorphic\alertnote{Is it really isomorphic?} computational model is postponed to the following \lcnamecref{ch:singleton-processes}.
% In this \lcnamecref{ch:singleton-logic}, we confine our attention to the proof-theoretic aspects of singleton logic.


\section{The single-antecedent restriction}\label{sec:singleton-logic:restriction}

As sketched above, the \emph{single-antecedent restriction} demands that each sequent contain exactly one antecedent, so that sequents are $\slseq{A |- B}$ instead of $\Gamma \vdash B$.

In addition to providing sequents with this elegant symmetry, the single-antecedent restriction is quite natural when independently viewed from the perspective of the computational trinity's\autocite{Harper:??} branches -- proof theory, category theory, and type theory.
%
\begin{description}
\item[Proof theory]
  In intuitionistic sequent calculi, antecedents are subject, either implicitly or explicitly, to structural properties, such as weakening, contraction, and exchange.
  For instance, antecedents in linear logic are subject to exchange, but neither weakening nor contraction; linear contexts thus form a commutative monoid.
  Ordered logic goes further and rejects exchange; ordered contexts thus form a (noncommutative) monoid.

  The single-antecedent restriction goes still further and rejects even the idea that contexts have structure.
  With only one antecedent, there can be no binary operation to concatenate contexts; singleton contexts form only a set, a degenerate algebraic structure.

\item[Category theory]
  Category without binary operation

\item[Type theory]
\end{description}

\section{Bringing symmetry to intuitionistic sequents}\label{sec:singleton-logic:derive}

The single-antecedent restriction described above
The sequents of singleton logic have exactly one consequent and, more characteristically, exactly one antecedent: $\slseq{A |- B}$ instead of $\oseq{\octx |- B}$.

In addition to providing sequents with this elegant symmetry, the single-antecedent restriction is also natural from a category-theoretic perspective.
In a category, each morphism $f\colon X \rightarrow Y$ has exactly one object -- no more and no less -- as its domain.
Because sequents should represent a kind of function, single antecedents are just as natural as single object domains.

Once we impose the single-antecedent restriction upon sequents, all of the rules from the sequent calculus for intuitionistic ordered logic must be reconsidered.


Having sketched a three-pronged justification for the naturality of a single-antecedent restriction, we now ...
One approach is to take the intuitionistic ordered sequent calculus of \cref{??}

Take the cut principle, for instance.
\begin{equation*}
  \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
    \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
\end{equation*}
Because the second premise already contains the antecedent $B$, the contexts $\octx'_L$ and $\octx'_R$ must be empty if the premise is to satisfy the single-antecedent restriction.
Under this constraint, the cut principle becomes:
\begin{equation*}
  \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
    \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
  \rightsquigarrow
  \infer{\oseq{\octx |- C}}{
    \oseq{\octx |- B} & \oseq{B |- C}}
\end{equation*}
We then replace the finitary context $\octx$ with a single antecedent, $A$, so that the rule's first premise and conclusion also satisfy the characteristic restriction:
\begin{equation*}
  \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
    \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
  \rightsquigarrow
  \infer{\oseq{\octx |- C}}{
    \oseq{\octx |- B} & \oseq{B |- C}}
  \rightsquigarrow
  \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
    \slseq{A |- B} & \slseq{B |- C}}
\end{equation*}
We could equally well justify this cut rule for singleton logic by first principles, as it expresses the composition of two well-formed sequents\alertinline{proofs?} in singleton logic.

We could equally well justify this cut rule for singleton logic by first principles, as it expresses the composition of two well-formed sequents\alertinline{proofs?} in singleton logic.
But the above method of considering  ...  the constraints imposed by the single-antecedent restriction  ...  gives us a way forward
\begin{equation*}
  \!\begin{gathered}
    \infer[\rrule{\plus}_1]{\oseq{\octx |- B_1 \plus B_2}}{
      \oseq{\octx |- B_1}}
    \quad
    \infer[\rrule{\plus}_2]{\oseq{\octx |- B_1 \plus B_2}}{
      \oseq{\octx |- B_2}}
    \\[3\jot]
    \infer[\lrule{\plus}]{\oseq{\octx'_L \oc (B_1 \plus B_2) \oc \octx'_R |- C}}{
      \oseq{\octx'_L \oc B_1 \oc \octx'_R |- C} & \oseq{\octx'_L \oc B_2 \oc \octx'_R |- C}}
  \end{gathered}
  \rightsquigarrow
  \!\begin{gathered}
    \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_1}}
    \quad
    \infer[\rrule{\plus}_2]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_2}}
    \\[3\jot]
    \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
      \slseq{B_1 |- C} & \slseq{B_2 |- C}}
  \end{gathered}
\end{equation*}

Not all connectives fare as well under the single-antecedent restriction as additive disjunction does.
Consider, for example, left-handed implication and its right rule.
\begin{equation*}
  \infer[\rrule{\limp}]{\oseq{\octx |- B_1 \limp B_2}}{
    \oseq{B_1 \oc \octx |- B_2}}
\end{equation*}
Beginning with the $\rrule{\limp}$ rule's conclusion, we must replace the finitary context $\octx$ with a single antecedent, $A$.
\begin{equation*}
  \infer[\rrule{\limp}]{\oseq{\octx |- B_1 \limp B_2}}{
    \oseq{B_1 \oc \octx |- B_2}}
  \rightsquigarrow
  \infer{\oseq{A |- B_1 \limp B_2}}{
    \oseq{B_1 \oc A |- B_2}}
\end{equation*}
Although the revised rule's conclusion is now a well-formed singleton logic sequent, 
\begin{equation*}
  \infer[\rrule{\limp}]{\oseq{\octx |- B_1 \limp B_2}}{
    \oseq{B_1 \oc \octx |- B_2}}
  \rightsquigarrow
  \infer{\oseq{A |- B_1 \limp B_2}}{
    \oseq{B_1 \oc A |- B_2}}
  \rightsquigarrow
  \infer[\rrule{\limp}?]{\slseq{A |- B_1 \limp B_2}}{
    \slseq{B_1 \fuse A |- B_2}}
\end{equation*}
Viewed through a category-theoretic lens, this rule is quite innocuous, even natural.
But from a proof-theoretic perspective, the meaning of a logical connective should be independent of other connectives, and this rule creates an objectionable dependence of left-handed implication upon ordered conjunction.
As a practical consequence, the subformula property would fail to hold under this rule.


\begin{equation*}
  \infer[\lrule{\limp}?]{\slseq{A \fuse (B_1 \limp B_2) |- C}}{
    \slseq{A |- B_1} & \slseq{B_2 |- C}}
\end{equation*}


Take the first right rule for additive disjunction, for instance.
\begin{equation*}
  \infer[\rrule{\plus}_1]{\oseq{\octx |- B_1 \plus B_2}}{
    \oseq{\octx |- B_1}}
\end{equation*}
Beginning with the rule's conclusion, we must replace the finitary context $\octx$ with a single antecedent, $A$.
\begin{equation*}
  \infer[\rrule{\plus}_1]{\oseq{\octx |- B_1 \plus B_2}}{
    \oseq{\octx |- B_1}}
  \rightsquigarrow
  \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1}}
\end{equation*}
Both the premise and conclusion sequents of the resulting rule are well-formed, making it a candidate for inclusion in singleton logic.

Additive disjunction's left rule in singleton logic can be derived similarly from the corresponding sequent calculus rule of intuitionistic ordered logic.
\begin{equation*}
  \infer[\lrule{\plus}]{\oseq{\octx \oc (B_1 \plus B_2) \oc \octx'_R |- C}}{
    \oseq{\octx |- B_1}}
  \rightsquigarrow
  \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1}}
\end{equation*}



\begin{marginfigure}
  \begin{inferences}
    \infer[\rrule{\pmir}?]{\slseq{A |- B_2 \pmir B_1}}{
      \slseq{A \fuse B_1 |- B_2}}
    \and
    \infer[\lrule{\pmir}?]{\slseq{(B_2 \pmir B_1) \fuse A |- C}}{
      \slseq{A |- B_1} & \slseq{B_2 |- C}}
  \end{inferences}
  \caption{Equally problematic rules for right-handed implication}
\end{marginfigure}

\begin{inferences}
  \infer[\rrule{\fuse}?]{\slseq{A_1 \fuse A_2 |- B_1 \fuse B_2}}{
    \slseq{A_1 |- B_1} & \slseq{A_2 |- B_2}}
  \and
  \infer[\lrule{\fuse}?]{\slseq{B_1 \fuse B_2 |- C}}{
    \slseq{B_1 \fuse B_2 |- C}}
\end{inferences}

\begin{inferences}
  \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1}}
  \and
  \infer[\rrule{\plus}_2]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_2}}
  \and
  \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
    \slseq{B_1 |- C} & \slseq{B_2 |- C}}
\end{inferences}

\section{A sequent calculus for singleton logic}\label{sec:singleton-logic:seq-calc}

\Cref{fig:singleton-logic:seq-calc} presents propositional singleton logic in full.
%
\begin{figure}[t]
  \begin{syntax*}
    Propositions &
      A & \alpha \mid A \plus B \mid \zero \mid A \with B \mid \top
  \end{syntax*}
  \begin{inferences}
    \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
    \and
    \infer[\jrule{ID}^A]{\slseq{A |- A}}{}
    \\
    \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_1}}
    \and
    \infer[\rrule{\plus}_2]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_2}}
    \and
    \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
      \slseq{B_1 |- C} & \slseq{B_2 |- C}}
    \\
    \text{(no $\rrule{\zero}$ rule)}
    \and
    \infer[\lrule{\zero}]{\slseq{\zero |- C}}{}
    \\
    \infer[\rrule{\with}]{\slseq{A |- B_1 \with B_2}}{
      \slseq{A |- B_1} & \slseq{A |- B_2}}
    \and
    \infer[\lrule{\with}_1]{\slseq{B_1 \with B_2 |- C}}{
      \slseq{B_1 |- C}}
    \and
    \infer[\lrule{\with}_2]{\slseq{B_1 \with B_2 |- C}}{
      \slseq{B_2 |- C}}
    \\
    \infer[\rrule{\top}]{\slseq{A |- \top}}{}
    \and
    \text{(no $\lrule{\top}$ rule)}
  \end{inferences}
  \caption{A sequent calculus for propositional singleton logic\label{fig:singleton-logic:seq-calc}}
\end{figure}
%
The well-formed propositions are exactly the additive propositions of ordered logic, and the complete set of inference rules has been derived from the ordered sequent calculus by 

Although the propositions of singleton logic are exactly the additive propositions of ordered logic, notice that singleton logic is \emph{not} the additive fragment of ordered logic.
For instance, the sequent $\oseq{A \oc B |- \top}$ is provable in the additive fragment of ordered logic, but $\slseq{A \oc B |- \top}$ is not even a well-formed sequent in singleton logic, for the simple reason that it violates the single-antecedent restriction.

\subsection{Metatheory: Cut elimination and identity expansion}

\begin{theorem}[Admissibility of cut]\label{thm:sync-cut-admissible}
  If cut-free proofs of $\slseq{A |- B}$ and $\slseq{B |- C}$ exist, then there exists a cut-free proof of $\slseq{A |- C}$.
\end{theorem}
%
\begin{proof}
  We use the standard technique for proving the admissibility of a cut principle\autocite{Pfenning:CUT} -- a lexicographic induction, first on the structure of the principal type, and then on the structures of the given proofs.

  We would especially like to draw a distinction between the primitive $\jrule{CUT}$ rule and the admissible $\jrule{CUT-N}$ rule:
  \begin{equation*}
    \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
    \qquad\text{and}\qquad
    \infer-[\jrule{CUT-N}^B]{A \Vdash C}{
      A \Vdash B & B \Vdash C}
  \end{equation*}
  From here on, we won't bother to be quite so pedantic, instead writing the admissible $\jrule{CUT-N}$ rule as
  \begin{equation*}
    \infer-[\jrule{CUT-N}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
  \end{equation*}
  with the understanding that this admissible rule may only be applied to cut-free proofs.

  One of the principal cases in this induction pairs the $\rrule{\plus}_1$ rule with the $\lrule{\plus}$ rule.
  If we represent the admissible $\jrule{CUT}$ rule with a dotted line, then that case is resolved as follows.
  \begin{equation*}
    \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
      \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
        \deduce{\slseq{A |- B_1}}{\DD_1}} &
      \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
        \deduce{\slseq{B_1 |- C}}{\EE_1} &
        \deduce{\slseq{B_2 |- C}}{\EE_2}}}
    % 
    \quad=\quad
    % 
    \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
      \deduce{\slseq{A |- B_1}}{\DD_1} &
      \deduce{\slseq{B_1 |- C}}{\EE_1}}
  \end{equation*}

  \begin{equation*}
    \infer-[\jrule{CUT}^A]{\slseq{A |- C}}{
      \infer[\jrule{ID}^A]{\slseq{A |- A}}{} &
        \deduce{\slseq{A |- C}}{\EE}}
    % 
    \quad=\quad
    % 
    \deduce{\slseq{A |- C}}{\EE}
  \end{equation*}

  \begin{equation*}
    \infer-[\jrule{CUT}^B]{\slseq{A_1 \plus A_2 |- C}}{
      \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- B}}{
        \deduce{\slseq{A_1 |- B}}{\DD_1} &
        \deduce{\slseq{A_2 |- B}}{\DD_2}} &
      \deduce{\slseq{B |- C}}{\EE}}
    % 
    \quad=\quad
    % 
    \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- C}}{
      \infer-[\jrule{CUT}^B]{\slseq{A_1 |- C}}{
        \deduce{\slseq{A_1 |- B}}{\DD_1} &
        \deduce{\slseq{B |- C}}{\EE}} &
      \infer-[\jrule{CUT}^B]{\slseq{A_2 |- C}}{
        \deduce{\slseq{A_2 |- B}}{\DD_2} &
        \deduce{\slseq{B |- C}}{\EE}}}
  \end{equation*}

  \begin{equation*}
    \infer-[\jrule{CUT}^B]{\slseq{A |- C_1 \plus C_2}}{
      \deduce{\slseq{A |- B}}{\DD} &
      \infer[\rrule{\plus}_1]{\slseq{B |- C_1 \plus C_2}}{
        \deduce{\slseq{B |- C_1}}{\EE_1}}}
    % 
    \quad=\quad
    % 
    \infer[\rrule{\plus}_1]{\slseq{A |- C_1 \plus C_2}}{
      \infer-[\jrule{CUT}^B]{\slseq{A |- C_1}}{
        \deduce{\slseq{A |- B}}{\DD} &
        \deduce{\slseq{B |- C_1}}{\EE_1}}}
  \end{equation*}
  There are no right commutative cut reductions involving left rules -- more symmetric than ordered logic.
\end{proof}

\begin{corollary}[Cut elimination]\label{thm:sync-cut-elim}
  If a proof of $\slseq{A |- C}$ exists, then a cut-free proof of $\slseq{A |- C}$ exists.
\end{corollary}
\begin{proof}
  By structural induction on the proof of $\slseq{A |- C}$, appealing to the admissibility of cut\parencref{thm:sync-cut-admissible} when encountering a $\jrule{CUT}$ rule.
\end{proof}

\begin{theorem}[Identity expansion]
  $\slseq{A |- A}$ for all propositions $A$.
\end{theorem}
%
\begin{proof}
  By induction on the structure of the proposition $A$.
  % \begin{gather*}
  %   \infer-[\mathrlap{\jrule{ID}^{A_1 \plus A_2}}]{\slseq{A_1 \plus A_2 |- A_1 \plus A_2}}{}
  %   \\=\\
  %   \infer[\mathrlap{\lrule{\plus}}]{\slseq{A_1 \plus A_2 |- A_1 \plus A_2}}{
  %     \infer[\rrule{\plus}_1]{\slseq{A_1 |- A_1 \plus A_2}}{
  %       \infer-[\jrule{ID}^{A_1}]{\slseq{A_1 |- A_1}}{}} &
  %     \infer[\mathrlap{\rrule{\plus}_2}]{\slseq{A_2 |- A_1 \plus A_2}}{
  %       \infer-[\mathrlap{\jrule{ID}^{A_2}}]{\slseq{A_2 |- A_2}}{}}}
  % \end{gather*}
\end{proof}


\section{An asynchronous sequent calculus for singleton logic}

\newcommand*{\approxident}{%
  \mathrel{\vcenter{\offinterlineskip
  \hbox{$\sim$}\vskip-.35ex\hbox{$\sim$}\vskip-.35ex\hbox{$\sim$}}}}

% For reasons better explained in future \lcnamecrefs{ch:singleton-logic}, we need a Curry--Howard interpretation of singleton logic as a session-type system for asynchronous processes.

Notice that there is more than one way to extend a proof of $\slseq{A |- B_1}$ to a proof of $\slseq{A |- B_1 \plus B_2}$.
Of course, the most obvious way is to simply apply the $\rrule{\plus}_1$ rule to the given proof.
Another, less direct way is to cut the given proof against an identity embellished with the $\rrule{\plus}_1$ rule.
\begin{equation*}
  \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1}}
  \qquad\text{and}\qquad
  \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1} &
    \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
      \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}}
\end{equation*}
In fact, these proofs do not merely conclude with the same sequent -- these proofs are related by cut reduction:
\begin{equation*}
  \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1} &
    \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
      \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}}
  \longrightarrow\longrightarrow\enspace
  \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1}}
\end{equation*}
This suggests that the $\rrule{\plus}_1$-embellished identity may be worthy of special consideration.

Suppose that we replace the usual $\rrule{\plus}_1$ rule with a new primitive rule that collapses the embellished identity.
\begin{equation*}
  \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
    \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}
  \rightsquigarrow
  \infer[\rrule{\plus}_1']{\slseq{B_1 |- B_1 \plus B_2}}{}
\end{equation*}


\begin{gather*}
  \infer[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
    \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_1} &
      \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
        \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}} &
    \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
      \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
  \\\equiv\\
  \infer[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
    \slseq{A |- B_1} &
    \infer[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{B_1 |- C}}{
      \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
        \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}} &
      \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
        \slseq{B_1 |- C} & \slseq{B_2 |- C}}}}
  \\\longrightarrow\longrightarrow\\
  \infer[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
    \slseq{A |- B_1} & \slseq{B_1 |- C}}
\end{gather*}

\begin{gather*}
  \infer[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
    \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_1}} &
    \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
      \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
  \\\longrightarrow\\
  \infer[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
    \slseq{A |- B_1} & \slseq{B_1 |- C}}
\end{gather*}


\begin{equation*}
  \selectR{\kay}[P]
  \approxident
  \spawn{P}{(\selectR{\kay}[\fwd])}
\end{equation*}

\begin{marginfigure}
  \begin{gather*}
    \infer[\rrule{\plus}_1]{\slof{A |- \selectR{\kay}[P] : B_1 \plus B_2}}{
      \slseq{A |- P : B_1}}
    \\\approxident\\
    \infer[\jrule{CUT}^{B_1}]{\slseq{A |- \spawn{P}{(\selectR{\kay}[\fwd])} : B_1 \plus B_2}}{
      \slseq{A |- P : B_1} &
      \infer[\rrule{\plus}_1]{\slseq{B_1 |- \selectR{\kay}[\fwd] : B_1 \plus B_2}}{
        \infer[\jrule{ID}]{\slseq{B_1 |- \fwd : B_1}}{}}}
  \end{gather*}
  \caption{}
\end{marginfigure}


  
\begin{gather*}
  \begin{lgathered}
    \spawn{(\selectR{\kay}[P])}{\caseL[\ell \in L]{\ell => Q_{\ell}}}
      \longrightarrow \spawn{P}{Q_{\kay}}
    \\
    \begin{aligned}
      \MoveEqLeft[.5]
      \spawn{\bigl(\spawn{P}{(\selectR{\kay}[\fwd])}\bigr)}{\caseL[\ell \in L]{\ell => Q_{\ell}}} \\[-.75\jot]
        &\equiv \spawn{P}{\bigl(\spawn{(\selectR{\kay}[\fwd])}{\caseL[\ell \in L]{\ell => Q_{\ell}}}\bigr)} \\[-.75\jot]
        % &\longrightarrow \spawn{P}{(\spawn{\fwd}{Q_{\kay}})} \\[-.75\jot]
        &\longrightarrow\longrightarrow \spawn{P}{Q_{\kay}}
    \end{aligned}
  \end{lgathered}
\end{gather*}

% \begin{gather*}
%   \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
%     \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
%       \slseq{A |- B_1}} &
%     \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
%       \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
%   =
%   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1} & \slseq{B_1 |- C}}
%   \\=\\
%   \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
%     \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
%       \slseq{A |- B_1} &
%       \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%         \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}} &
%     \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
%       \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
%   \equiv
%   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
%     \slseq{A |- B_1} &
%     \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{B_1 |- C}}{
%       \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%         \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}} &
%       \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
%         \slseq{B_1 |- C} & \slseq{B_2 |- C}}}}
%   \\=\\
%   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
%     \slseq{A |- B_1} &
%     \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{B_1 |- C}}{
%       \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{} &
%       \slseq{B_1 |- C}}}
%   \\=\\
%   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
%     \slseq{A |- B_1} & \slseq{B_1 |- C}}
% \end{gather*}


\begin{equation*}
  \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
    \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}
  \leftrightsquigarrow
  \infer[\rrule{\plus}_1']{\slseq{B_1 |- B_1 \plus B_2}}{}
\end{equation*}


\begin{equation*}
  \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1}}
  \leftrightsquigarrow
  \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
    \slseq{A |- B_1} &
    \infer[\rrule{\plus}_1']{\slseq{B_1 |- B_1 \plus B_2}}{}}
\end{equation*}


\begin{equation*}
  \infer-[\jrule{CUT}^{A_1}]{\slseq{A_1 |- C}}{
    \infer[\rrule{\plus}_1']{\slseq{A_1 |- A_1 \plus A_2}}{} &
    \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- C}}{
      \deduce{\slseq{A_1 |- C}}{\EE_1} &
      \deduce{\slseq{A_2 |- C}}{\EE_2}}}
  \rightsquigarrow
  \deduce{\slseq{A_1 |- C}}{\EE_1}
\end{equation*}


\begin{syntax*}
  Propositions &
    A & \alpha \mid A \plus B \mid \zero \mid A \with B \mid \top
\end{syntax*}

\begin{inferences}
  \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
    \slseq{A |- B} & \slseq{B |- C}}
  \and
  \infer[\jrule{ID}^A]{\slseq{A |- A}}{}
  \\
  \infer[\rrule{\plus}_1']{\slseq{A_1 |- A_1 \plus A_2}}{}
  \and
  \infer[\rrule{\plus}_2']{\slseq{A_2 |- A_1 \plus A_2}}{}
  \and
  \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- C}}{
    \slseq{A_1 |- C} & \slseq{A_2 |- C}}
  \\
  \text{(no $\rrule{\zero}$ rule)}
  \and
  \infer[\lrule{\zero}]{\slseq{\zero |- C}}{}
  \\
  \infer[\rrule{\with}]{\slseq{A |- C_1 \with C_2}}{
    \slseq{A |- C_1} & \slseq{A |- C_2}}
  \and
  \infer[\lrule{\with}_1']{\slseq{C_1 \with C_2 |- C_1}}{}
  \and
  \infer[\lrule{\with}_2']{\slseq{C_1 \with C_2 |- C_2}}{}
  \\
  \infer[\rrule{\top}]{\slseq{A |- \top}}{}
  \and
  \text{(no $\lrule{\top}$ rule)}
\end{inferences}


\begin{syntax*}
  Proof terms &
    P & \begin{array}[t]{@{}l@{}}
          \spawn{P_1}{P_2} \mid \fwd \\
          \begin{array}[t]{@{\mathllap{\mid {}}}l@{}}
            \selectR{\kay} \mid \caseL[\ell \in L]{\ell => P_{\ell}} \\
            \caseR[\ell \in L]{\ell => P_{\ell}} \mid \selectL{\kay}
          \end{array}
        \end{array}
\end{syntax*}

\begin{inferences}
  \infer[\jrule{CUT}^B]{\slseq{A |- \spawn{P_1}{P_2} : C}}{
    \slseq{A |- P_1 : B} & \slseq{B |- P_2 : C}}
  \and
  \infer[\jrule{ID}^A]{\slseq{A |- \fwd : A}}{}
  \\
  \infer[\rrule{\plus}]{\slseq{A_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}}}{
    \text{($\kay \in L$)}}
  \and
  \infer[\lrule{\plus}]{\slseq{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} |- \caseL[\ell \in L]{\ell => P_{\ell}} : C}}{
    \multipremise{\ell \in L}{\slseq{A_{\ell} |- P_{\ell} : C}}}
  \\
  \infer[\rrule{\with}]{\slseq{A |- \caseR[\ell \in L]{\ell => P_{\ell}} : \with*[sub=_{\ell \in L}]{\ell:C_{\ell}}}}{
    \multipremise{\ell \in L}{\slseq{A |- P_{\ell} : C_{\ell}}}}
  \and
  \infer[\lrule{\with}]{\slseq{\with*[sub=_{\ell \in L}]{\ell:C_{\ell}} |- \selectL{\kay} : C_{\kay}}}{
    \text{($\kay \in L$)}}
\end{inferences}


\subsection{An analogue of cut elimination}

\begin{equation*}
  \infer-[\jrule{CUT-N}^B]{\slof{A |- \nspawn{N}{M} : C}}{
    \slof{A |- N : B} & \slof{B |- M : C}}
\end{equation*}

While the above approach does establish admissibility, the principal cases do not suggest an asynchronous operational semantics quite as strongly as they might.
Here is a different approach that gives a better match with the eventual operational semantics.
The grammar of normal terms changes slightly:
\begin{syntax*}
  Normal terms &
    N,M & \begin{array}[t]{@{}l@{}}
            \fwd \mid \spawn{N}{\selectR{\kay}} \mid \spawn{\selectL{\kay}}{N} \\
            \begin{array}[t]{@{\mathllap{\mid {}}}l@{}}
              \selectR{\kay} \mid \caseL[\ell \in L]{\ell => N_{\ell}} \\
              \caseR[\ell \in L]{\ell => N_{\ell}} \mid \selectL{\kay}
            \end{array}
          \end{array}
\end{syntax*}

\begin{gather*}
  \infer-[\jrule{CUT-N}^B]{\slof{A |- \nspawn{(\spawn{N_0}{\selectR{\kay}})}{M} : C}}{
    \infer[\jrule{CUT}^{B_{\kay}}]{\slof{A |- \spawn{N_0}{\selectR{\kay}} : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
      \slof{A |- N_0 : B_{\kay}} &
      \infer[\rrule{\plus}]{\slof{B_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
        \text{($\kay \in L$)}}} &
    \slof{\plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- M : C}}
  \\=\\
  \infer-[\jrule{CUT-N}^{B_{\kay}}]{\slof{A |- \nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})} : C}}{
    \slof{A |- N_0 : B_{\kay}} &
    \infer-[\jrule{CUT-N}^B]{\slof{B_{\kay} |- \nspawn{\selectR{\kay}}{M} : C}}{
      \infer[\rrule{\plus}]{\slof{B_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
        \text{($\kay \in L$)}} &
    \slof{\plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- M : C}}}
\end{gather*}


\begin{description}
\item[Identity cuts]
  \begin{gather*}
    \nspawn{\fwd}{M} = M \\
    \nspawn{N}{\fwd} = N
  \end{gather*}

\item[Associative cuts]
  \begin{gather*}
    \nspawn{(\spawn{N_0}{\selectR{\kay}})}{M} = \nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})} \\
    \nspawn{N}{(\spawn{\selectL{\kay}}{M_0})} = \nspawn{(\nspawn{N}{\selectL{\kay}})}{M_0}
  \end{gather*}

\item[Principal cuts]
  \begin{gather*}
    \nspawn{\selectR{\kay}}{\caseL[\ell \in L]{\ell => M_{\ell}}} = M_{\kay} \\
    \nspawn{\caseR[\ell \in L]{\ell => N_{\ell}}}{\selectL{\kay}} = N_{\kay}
  \end{gather*}

\item[Left commutative cuts]
  \begin{gather*}
    \nspawn{\selectL{\kay}}{M} = \spawn{\selectL{\kay}}{M} \\
    \nspawn{(\spawn{\selectL{\kay}}{N_0})}{M} = \spawn{\selectL{\kay}}{(\nspawn{N_0}{M})} \\
    \nspawn{\caseL[\ell \in L]{\ell => N_{\ell}}}{M} =
      \begin{array}[t]{@{}l@{}}
        \caseL[\ell \in L]{\ell => \nspawn{N_{\ell}}{M}} \mathrlap{\,,} \\
        \mathrlap{\quad\text{if $M \neq \selectR{\kay}$ and $M \neq \spawn{M_0}{\selectR{\kay}}$ for all $M_0$}}
      \end{array}
  \end{gather*}
  Without this side condition, the grammar of normal terms would include reducible terms like $\spawn{\caseL[\ell \in L]{\ell => N_{\ell}}}{\selectR{\kay}}$.

\item[Right commutative cuts]
  \begin{gather*}
    \nspawn{N}{\selectR{\kay}} = \spawn{N}{\selectR{\kay}} \\
    \nspawn{N}{(\spawn{M_0}{\selectR{\kay}})} = \spawn{(\nspawn{N}{M_0})}{\selectR{\kay}} \\
    \nspawn{N}{\caseR[\ell \in L]{\ell => M_{\ell}}} =
      \begin{array}[t]{@{}l@{}}
        \caseR[\ell \in L]{\ell => \nspawn{N}{M_{\ell}}} \mathrlap{\,,} \\
        \mathrlap{\quad\text{if $N \neq \selectL{\kay}$ and $N \neq \spawn{\selectL{\kay}}{N_0}$ for all $N_0$}}
      \end{array}
  \end{gather*}
\end{description}
Proving termination of this second procedure is slightly more involved than that of the first approach.
We still use a lexicographic induction, but instead of using the structure of the type and then the structures of the proofs, we may need to introduce an explicit metric.
Consider
\begin{equation*}
  \nspawn{(\spawn{N_0}{\selectR{\kay}})}{M}
    = \nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})} \,.
\end{equation*}
The inner cut uses thie same type with smaller proofs; the outer cut uses a smaller type.
In case $\selectR{\kay}$ is not considered a structural component of $\spawn{N_0}{\selectR{\kay}}$, then we can use a metric that sets
\begin{align*}
  \lvert \spawn{N_0}{\selectR{\kay}} \rvert &= 2 + \lvert N_0 \rvert \\
\shortintertext{and}
  \lvert \selectR{\kay} \rvert &= 1 \,.
\end{align*}


% \subsection{Operational semantics}

% \begin{syntax*}
%   Configurations & \cnf & \cnf_1 \cc \cnf_2 \mid \cnfe \mid P
% \end{syntax*}

% \begin{equation*}
%   \begin{gathered}
%     \!\begin{aligned}
%       \fwd &\reduces \cdot \\
%       \spawn{P_1}{P_2} &\reduces P_1 \cc P_2
%     \end{aligned} \\
%     \selectR{\kay} \cc \caseL[\ell \in L]{\ell => P_{\ell}}
%       \reduces P_{\kay} \\
%     \caseR[\ell \in L]{\ell => P_{\ell}} \cc \selectL{\kay}
%       \reduces P_{\kay}
%     \\[2\jot]
%     \cnf \cc \cnfe = \cnf = \cnfe \cc \cnf \\
%     (\cnf_1 \cc \cnf_2) \cc \cnf_3 = \cnf_1 \cc (\cnf_2 \cc \cnf_3)
%   \end{gathered}
% \end{equation*}

% \begin{equation*}
%   \begin{aligned}
%     (\cnf_1 \cc \cnf_2)^\sharp &= \spawn{\cnf_1^\sharp}{\cnf_2^\sharp} \\
%     (\cnfe)^\sharp &= \fwd \\
%     P^\sharp &= P
%   \end{aligned}
% \end{equation*}



\section{Extensions of singleton logic}\label{sec:singleton-logic:extensions}

\begin{itemize}
\item Multiplicative units (subsingletons)
\item Exponentials
\end{itemize}

\begin{syntax*}
  Propositions & A & \dotsb \mid \one \\
  Contexts & \sctx & A \mid \sctxe
\end{syntax*}

\begin{inferences}
  \infer[\rrule{\one}]{\slseq{\sctxe |- \one}}{}
  \and
  \infer[\lrule{\one}]{\slseq{\one |- C}}{
    \slseq{\sctxe |- C}}
\end{inferences}

\begin{syntax*}
  Propositions & A & \dotsb \mid \bot \\
  Conseq\relax uents & \cseq & C \mid \cseqe
\end{syntax*}

\begin{inferences}
  \infer[\rrule{\bot}]{\slseq{\sctx |- \bot}}{
    \slseq{\sctx |- \cseqe}}
  \and
  \infer[\lrule{\bot}]{\slseq{\bot |- \cseqe}}{}
\end{inferences}

\begin{syntax*}
  Propositions & A & \dotsb \mid \bang A \\
  Persistent contexts & \uctx & \uctxe \mid \uctx, A
\end{syntax*}

\begin{inferences}
  \infer[\jrule{CUT!}^A]{\slseq{\uctx, A ; \sctx |- \cseq}}{
    \slseq{\uctx ; \sctxe |- A} & \slseq{\uctx, A ; \sctx |- \cseq}}
  \and
  \infer[\jrule{COPY}]{\slseq{\uctx, A ; \sctxe |- \cseq}}{
    \slseq{\uctx, A ; A |- \cseq}}
  \\
  \infer[\rrule{\bang}]{\slseq{\uctx ; \sctxe |- \bang A}}{
    \slseq{\uctx ; \sctxe |- A}}
  \and
  \infer[\lrule{\bang}]{\slseq{\uctx ; \bang A |- \cseq}}{
    \slseq{\uctx, A ; \sctxe |- \cseq}}
\end{inferences}

\begin{inferences}
  \infer[\rrule{\bang\tensor}]{\slseq{\uctx ; \sctx |- A_1 \mathbin{\bang\tensor} A_2}}{
    \slseq{\uctx ; \sctxe |- A_1} & \slseq{\uctx ; \sctx |- A_2}}
  \and
  \infer[\lrule{\bang\tensor}]{\slseq{\uctx ; A_1 \mathbin{\bang\tensor} A_2 |- \cseq}}{
    \slseq{\uctx, A_1 ; A_2 |- \cseq}}
\end{inferences}

\begin{inferences}
  \infer[\rrule{\bang}]{\slseq{\uctx, A ; \sctxe |- \bang A}}{}
  \and
  \infer[\rrule{\bang\tensor}]{\slseq{\uctx, A_1 ; A_2 |- A_1 \mathbin{\bang\tensor} A_2}}{}
\end{inferences}


\section{Related work}\label{sec:singleton-logic:related-work}

\begin{itemize}
\item Fortier and Santocanale paper using (synchronous) singleton logic
\item CSL '12 paper on asynchronous Curry--Howard for linear logic
\end{itemize}


\section{Hilbert}

\NewDocumentCommand{\sem}{m}{\llbracket#1\rrbracket}

\begin{equation*}
  \begin{lgathered}
    \sem{x}\,\rho = \rho(x) \\
    \sem{\lambda x.M}\,\rho\,v = \sem{M}\,(\rho[x \mapsto v]) \\
    \sem{M\,N}\,\rho = \sem{M}\,\rho\,(\sem{N}\,\rho)
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    \sem{0}\,(\rho, v_0) = v_0 \qquad \sem{n+1}\,(\rho, v_0) = \sem{n}\,\rho \\
    \sem{\lambda x.M}\,\rho\,v_0 = \sem{M}\,(\rho, v_0) \\
    \sem{M\,N}\,\rho = \sem{M}\,\rho\,(\sem{N}\,\rho)
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    \sem{n} = \pi\,n \\
    \sem{\lambda x.M} = \Lambda\,\sem{M} \\
    \sem{M\,N} = S\,\sem{M}\,\sem{N}
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    \pi\,0\,(x,y) = y \qquad \pi\,(n+1)\,(x,y) = \pi\,n\,x \\
    \Lambda\,f\,x\,y = f\,(x,y) \\
    S\,x\,y\,z = x\,z\,(y\,z)
  \end{lgathered}
\end{equation*}


\begin{equation*}
  \begin{lgathered}
    \vdash \circ : (B \to C) \to (A \to B) \to (A \to C) \\
    \vdash \iota_1 : A \to A \lor B \\
    \vdash \iota_2 : B \to A \lor B \\
    f{:}A \to C, g{:}B \to C \vdash [f,g] : A \lor B \to C
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    [f_1,f_2]\,(\iota_i\,x) = f_i\,x \\
    [f_1,f_2] \circ \iota_i = f_i
  \end{lgathered}
\end{equation*}


\begin{equation*}
  \begin{lgathered}
    \sem{\selectR{i_1}[P]} = S_1\,\sem{P} \\
    \sem{\caseL{i_1 => Q_1 | i_2 => Q_2}} = [\sem{Q_1}, \sem{Q_2}] \\
    \sem{\spawn{P}{Q}} = \sem{Q} \circ \sem{P}
  \end{lgathered}
\end{equation*}

\begin{equation*}
  [g_1, g_2](S_1\,f\,x) = g_1(f\,x) and S_1\,f\,x = \iota_1\,(f\,x)
\end{equation*}

\section{Natural deduction}

\begin{inferences}
  \infer[\jrule{HYP}]{A \vdash A}{}
  \and
  \infer-[\jrule{SUBST}]{A \vdash C}{
    A \vdash B & B \vdash C}
  \\
  \infer[{\plus}\text{\scshape i}]{A \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}{
    A \vdash B_{\kay} & \text{($\kay \in L$)}}
  \and
  \infer[{\plus}\text{\scshape e}]{A \vdash C}{
    A \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} &
    \multipremise{\ell \in L}{\!\!\!B_{\ell} \vdash C}}
  \\
  \infer[{\with}\text{\scshape i}]{A \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}}}{
    \multipremise{\ell \in L}{\!\!\!A \vdash B_{\ell}}}
  \and
  \infer[{\with}\text{\scshape e}]{A \vdash B_{\kay}}{
    A \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} & \text{($\kay \in L$)}}
\end{inferences}

\begin{theorem}
  If $A \vdash B$ in natural deduction, then $\slseq{A |- B}$ in the sequent calculus.
\end{theorem}
\begin{proof}
  \begin{equation*}
    \infer[{\with}\text{\scshape e}]{A \vdash B_{\kay}}{
      A \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} & \text{($\kay \in L$)}}  
    \rightsquigarrow
    \infer[\jrule{CUT}]{\slseq{A |- B_{\kay}}}{
      \slseq{A |- \with*[sub=_{\ell \in L}]{\ell:B_{\ell}}} &
      \infer[\lrule{\with}]{\slseq{\with*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- B_{\kay}}}{
        \text{($\kay \in L$)}}}
  \end{equation*}
\end{proof}

\begin{theorem}
  If $A \vdash B$ in sequent calculus, then $\slseq{A |- B}$ in the natural deduction.
\end{theorem}
\begin{proof}
  \begin{gather*}
    \infer[\lrule{\with}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      A_{\kay} \vdash C & \text{($\kay \in L$)}}
    \\\rightsquigarrow\\
    \infer-[\jrule{SUBST}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      \infer[{\with}\text{\scshape e}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash A_{\kay}}{
        \infer[\jrule{HYP}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash \with*[sub=_{\ell \in L}]{\ell:A_{\ell}}}{} &
        \text{($\kay \in L$)}} &
      A_{\kay} \vdash C}
  \end{gather*}

  \begin{gather*}
    \infer[\lrule{\plus}]{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      \multipremise{\ell \in L}{\!\!\!A_{\ell} \vdash C}}
    \\\rightsquigarrow\\
    \infer[{\plus}\text{\scshape e}]{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      \infer[\jrule{HYP}]{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}}{} &
      \multipremise{\ell \in L}{\!\!\!A_{\ell} \vdash C}}
  \end{gather*}
\end{proof}


\begin{inferences}
  \infer[\jrule{HYP}]{A \dn \vdash A \dn}{}
  \and
  \infer-[\jrule{SUBST}]{A \dn \vdash C \up}{
    A \dn \vdash B \dn & B \dn \vdash C \up}
  \and
  \infer-[\jrule{SUBST}]{A \dn \vdash C \dn}{
    A \dn \vdash B \dn & B \dn \vdash C \dn}
  \\
  \infer[{\plus}\text{\scshape i}]{A \dn \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} \up}{
    A \dn \vdash B_{\kay} \up & \text{($\kay \in L$)}}
  \and
  \infer[{\plus}\text{\scshape e}]{A \dn \vdash C \up}{
    A \dn \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} \up &
    \multipremise{\ell \in L}{\!\!\!B_{\ell} \dn \vdash C \up}}
  \\
  \infer[{\with}\text{\scshape i}]{A \dn \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} \up}{
    \multipremise{\ell \in L}{\!\!\!A \dn \vdash B_{\ell} \up}}
  \and
  \infer[{\with}\text{\scshape e}]{A \dn \vdash B_{\kay} \dn}{
    A \dn \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} \dn & \text{($\kay \in L$)}}
\end{inferences}

  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
