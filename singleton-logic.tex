\chapter{Singleton logic}\label{ch:singleton-logic}

Intuitionistic sequents are typically asymmetric:
in an intuitionistic sequent $\Gamma \vdash A$, there are finitely many antecedents, all collected into the context $\Gamma$, yet there is only a single consequent, $A$.%
\footnote{Or, at most one consequent if multiplicative falsehood is included\parencref[see, for example,]{sec:ordered-logic:mult-falsehood}.}
We might naturally wonder if a greater degree of symmetry can be brought to sequents.
% Of course, classical sequents in calculi such as Gentzen's LK\autocite{Gentzen:??} do enjoy a pleasant symmetry, but does there exist an \emph{intuitionistic} logic whose sequent calculus presentation uses symmetric sequents?
Of course, classical sequents in calculi such as Gentzen's LK\autocite{Gentzen:??} are symmetric, but does there exist an \emph{intuitionistic} logic whose sequent calculus presentation enjoys a similarly pleasant symmetry?

One approach might be to permit finitely many consequents, as in multiple-conclusion sequent calculi for intuitionistic logic\autocite{??}, but \citeauthor{Steinberger:JPL11}\autocite{Steinberger:JPL11} raises troubling concerns about the validity of meaning-theoretic explanations of such calculi.

So, in this \lcnamecref{ch:singleton-logic}, we will instead follow a dual path to symmetry and examine a restriction in which sequents have exactly one antecedent -- no more and no less.
We call this requirement the \emph{single-antecedent restriction}; the sequent calculus to which it leads, the \emph{singleton sequent calculus}; and the underlying logic, \emph{singleton logic}.
That such a severe restriction on the structure of sequents yields a well-defined, computationally useful logic is quite surprising.

\newthought{Aside from} motivations of symmetry, the single-antecedent restriction is sensible within each branch of the computational trinity\autocite{Harper:??} -- proof theory, category theory, and type theory -- as we sketch in \cref{sec:singleton-logic:restriction}.
This \lcnamecref{ch:singleton-logic} will thereafter focus on the proof-theoretic consequences of the single-antecedent restriction.
% [This \lcnamecref{ch:singleton-logic} is primarily devoted to the proof-theoretic consequences of the single-antecedent restriction, so the operational aspects are mostly postponed to \cref{ch:singleton-processes}.]

Having fully motivated the single-antecedent restriction, we then proceed to \cref{sec:singleton-logic:seq-calc} where we derive the singleton sequent calculus by systematically applying the restriction to the intuitionistic ordered sequent calculus of \cref{??}.
[Not all of the ordered logical connectives will be able to survive the restriction, however.
As we will explain, it is precisely the multiplicative connectives that are absent from singleton logic.]

To ensure that the resulting calculus properly defines the meaning of each connective by its inference rules, \cref{sec:singleton-logic:seq-calc:metatheory} establishes the calculus's basic metatheory.
Together, the cut elimination and identity elimination metatheorems identify the cut-free, $\eta$-long proofs as analytic verifications that exhibit a subformula property.

To ensure that the resulting calculus is indeed a sequent calculus with the characteristic verificationist meaning-explanation, \cref{sec:singleton-logic:seq-calc:metatheory} then establishes its basic metatheory.
Together, the cut elimination and identity expansion metatheorems identify the cut-free, $\eta$-long proofs as analytic verifications that exhibit a subformula property.

There are certainly other presentations of logics besides sequent calculi.
So, in \cref{sec:singleton-logic:hilbert}, we consider a Hilbert-style axiomatization of singleton logic that can also be viewed as a variant of the sequent calculus.
Our interest in a Hilbert system is not, however, zoological; an analysis of the Hilbert system's basic metatheory\parencref{sec:singleton-logic:hilbert:metatheory} begins to suggest the basis of a Curry--Howard interpretation of Hilbert-style proofs as asynchronously communicating processes.
\Cref{ch:singleton-processes} will be devoted to developing that observation more fully.

% Although the single-antecedent restriction precludes a true Hilbert system, we are able to consruct a Hilbert-like system that can also be viewed as a variant of the singleton sequent calculus.


% \Cref{sec:singleton-logic:hilbert:metatheory} establishes the admissibility of a modus ponens-like rule, and contrasts the proof with that of admissibility of cut from \cref{sec:singleton-logic:metatheory}.

Finally, \cref{sec:singleton-logic:subsingleton} briefly overviews several possible extensions to singleton logic.



% Intuitionistic sequents often contain
% \begin{description}
% \item[Proof-theoretical]
%   Under the single-antecedent restriction, sequents enjoy an elegant symmetry -- exactly one consequent and now exactly one antecedent -- $\slseq{A |- B}$ rather than $\oseq{\octx |- B}$.
% \item[Categorical]
% \item[Operational] 
% \end{description}
% That such a drastic restriction on the structure of sequents yields a well-defined, computationally useful logic is rather surprising.

% Recall from \cref{ch:ordered-logic} that the sequents of intuitionistic ordered logic are inherently asymmetric.
% In an ordered sequent such as $\oseq{\octx |- A}$, there are finitely many antecedents, all collected into the context $\octx$, yet there is only a single consequent.%
% \footnote{Or, at most one consequent if multiplicative falsehood is included\parencref[see]{sec:ordered-logic:mult-falsehood}.}
% We might naturally wonder if a greater degree of symmetry can be brought to these ordered sequents.
% Does there exist a related logic whose sequent calculus presentation uses symmetric sequents?

% To achieve greater symmetry, intuitionism could, of course, be abandoned in favor of a classical noncommutative logic~\autocite{Abrusci:JSL91}.
% One alternative that maintains an intuitionistic character might be to permit finitely many consequents, in a vein similar to multiple-conclusion sequent calculi for intuitionistic logic\autocite{??}.%
% \footnote{However, \textcite{Steinberger:JPL11} raises troubling concerns about meaning-theoretic explanations of such calculi.}

% However, in this \lcnamecref{ch:singleton-logic}, we will instead follow a dual path to symmetry and examine a fragment of intuitionistic ordered logic that is obtained by requiring sequents to have exactly one antecedent -- no more and no less.
% We call this requirement the \emph{single-antecedent restriction} and the logical fragment to which it leads \emph{singleton logic}.
% That such a drastic restriction on the structure of sequents yields a well-defined, computationally useful logic is rather surprising.

% We will begin our examination of singleton logic in \cref{sec:singleton-logic:derive} by deriving its sequent calculus from that of intuitionistic ordered logic by a systematic application of the single-antecedent restriction.
% \Cref{sec:singleton-logic:seq-calc} then establishes the basic metatheory of singleton logic's sequent calculus: identity expansion and, more importantly, admissibility of cut.

% By analogy with a Curry--Howard interpretation of intuitionistic linear logic\autocite{Toninho:?}, we will argue in \cref{sec:singleton-logic:?} that the proof of admissibility of cut describes inherently synchronous interactions between proofs.
% Such a calculus is not well-suited to the remainder of ...

% So, in \cref{sec:singleton-logic:async-seq-calc}, we develop a novel form of sequent calculus and accompanying proof of admissibility of cut that describes inherently asynchronous interactions between proofs.

% A discussion of singleton logic's computational model\alertinline{interpretation?} is postponed to the following \lcnamecref{ch:singleton-processes}.
% In this \lcnamecref{ch:singleton-logic}, we confine our attention to the proof-theoretic aspects of singleton logic.


%  and require exactly one antecedent.

%  we present one such logic, \emph{singleton logic}.
% As its name suggests, singleton logic is the fragment of ordered logic obtained by requiring sequents to have exactly one antecedent -- no more and no less.
% That such a drastic restriction on the structure of contexts yields a well-defined, computationally useful logic is somewhat surprising.

% A discussion of singleton logic's isomorphic\alertnote{Is it really isomorphic?} computational model is postponed to the following \lcnamecref{ch:singleton-processes}.
% In this \lcnamecref{ch:singleton-logic}, we confine our attention to the proof-theoretic aspects of singleton logic.


\section{The single-antecedent restriction}\label{sec:singleton-logic:restriction}

As sketched above, the \emph{single-antecedent restriction} demands that each sequent contain exactly one antecedent, so that sequents are $\slseq{A |- B}$ instead of $\Gamma \vdash B$.

In addition to providing sequents with an elegant symmetry between antecedents and consequents, the single-antecedent restriction is a worthwhile object of investigation when viewed from the perspective of each of the computational trinity's\autocite{Harper:??} branches -- proof theory, category theory, and type theory.
%
\begin{description}
\item[Proof theory]
  In sequent calculi, antecedents are subject, either implicitly or explicitly, to structural properties, such as weakening, contraction, and exchange.
  For instance, antecedents in linear logic are subject to exchange, but neither weakening nor contraction; linear contexts thus form a commutative monoid over antecedents.
  Ordered logic goes further and rejects exchange; ordered contexts thus form a noncommutative monoid.

  The single-antecedent restriction goes still further and rejects the very idea that contexts have any structure at all.
  Under this restriction, there can be no binary operation to catenate contexts, so singleton contexts form only the degenerate algebraic structure of a set.

\item[Category theory]
  Each morphism in a category, $f\colon X \rightarrow Y$, has exactly one object -- no more and no less -- as its domain.
  Because sequents represent a kind of function, single antecedents are just as natural as single-object domains.

  More specifically, in categorical semantics of sequent calculi, proofs are represented by the morphisms of a monoidal category, and so contexts of several antecedents are packaged into a single domain object using the monoidal product:
  % Because proofs sequents should represent a kind of function, categorical semantics for sequent calculi package contexts of several antecedents into a single domain object using a categorical product
  \begin{equation*}
    \ulcorner \DD :: (A_1, A_2, \dotsc, A_n \vdash B) \urcorner :
      \ulcorner\mkern-1mu A_1 \mkern-\thinmuskip\urcorner \otimes \ulcorner\mkern-1mu A_2 \mkern-\thinmuskip\urcorner \otimes \dotsb \otimes \ulcorner\mkern-1mu A_n \mkern-\thinmuskip\urcorner \to \ulcorner B \urcorner
  \end{equation*}
  Because working in a monoidal category complicates matters, it is worthwhile to consider whether there exists a sequent calculus whose categorical semantics uses no monoidal product.
  % Because the tensor product complicates the category, it is worthwhile to consider whether there exists a sequent calculus whose categorical semantics uses no tensor product.
  The single-antecedent restriction is exactly what results from these considerations, and the singleton sequent calculus will have a cleaner, more direct categorical semantics because of it.

\item[Type theory]
  \begin{tikzpicture}
    \graph [nodes={draw}, math nodes,->=o-] {
      { / [coordinate] , / [coordinate] }
       --
      P [circle]
       ->
      / [coordinate];
    };
  \end{tikzpicture}

  \begin{tikzpicture}
    \graph [nodes={draw}, math nodes] {
      / [coordinate] -- P [circle] -> / [coordinate];
    };
  \end{tikzpicture}

\end{description}


\section{A sequent calculus for propositional singleton logic}\label{sec:singleton-logic:seq-calc}

Having sketched proof-theoretic, category-theoretic, and type-theoretic reasons to investigate the single-antecedent restriction, we turn to identifying a sequent calculus that satisfies that restriction.

% \subsection{Deriving the sequent calculus rules}\label{sec:singleton-logic:seq-calc:derive}

% The single-antecedent restriction described above
% The sequents of singleton logic have exactly one consequent and, more characteristically, exactly one antecedent: $\slseq{A |- B}$ instead of $\oseq{\octx |- B}$.

% In addition to providing sequents with this elegant symmetry, the single-antecedent restriction is also natural from a category-theoretic perspective.
% In a category, each morphism $f\colon X \rightarrow Y$ has exactly one object -- no more and no less -- as its domain.
% Because sequents should represent a kind of function, single antecedents are just as natural as single object domains.

% Once we impose the single-antecedent restriction upon sequents, all of the rules from the sequent calculus for intuitionistic ordered logic must be reconsidered.

\newthought{One approach} to constructing a singleton sequent calculus is to take the intuitionistic ordered sequent calculus of \cref{??}, apply the single-antecedent restriction to each rule's sequents, and solve the constraints that that restriction imposes.
% upon the ordered sequent calculus's rules.

For instance, consider the ordered cut rule (see neighboring \lcnamecref{fig:singleton-logic:seq-calc:derive-cut}).
%
\begin{marginfigure}[7.5\baselineskip]
  \normalsize
  \begin{gather*}
    \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
      \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
    \\
    \mathord{\downsquigarrow}\hspace{5pt}\hphantom{\jrule{CUT}^B}
    \\
    \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
  \end{gather*}
  \caption{Deriving the singleton sequent calculus's cut rule from the corresponding ordered sequent calculus rule}\label{fig:singleton-logic:seq-calc:derive-cut}
\end{marginfigure}
%
% \begin{equation*}
%   \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
%     \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
% \end{equation*}
For the first premise to satisfy the single-antecedent restriction, the finitary context $\octx$ must be exactly a single antecedent, $A$.
Because the second premise already contains the antecedent $B$, the contexts $\octx'_L$ and $\octx'_R$ must also be empty.
After these revisions, the rule contains only well-formed singleton sequents and is a candidate for inclusion in the singleton sequent calculus.

% With these revisions, all sequents of the resulting rule are well-formed singleton sequents, 


% Because the second premise already contains the antecedent $B$, the contexts $\octx'_L$ and $\octx'_R$ must be empty if the premise is to satisfy the single-antecedent restriction.
% % Under this constraint, the cut principle becomes:
% % \begin{equation*}
% %   \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
% %     \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
% %   \rightsquigarrow
% %   \infer{\oseq{\octx |- C}}{
% %     \oseq{\octx |- B} & \oseq{B |- C}}
% % \end{equation*}
% We then replace the finitary context $\octx$ with a single antecedent, $A$, so that the rule's first premise and conclusion also satisfy the [characteristic] restriction.
% All sequents of the resulting rule are well-formed, making it a candidate for inclusion in the singleton sequent calculus.
% % \begin{equation*}
% %   \begin{array}{@{}ccl@{}}
% %     \text{\scshape ordered logic} && \text{\scshape singleton logic}
% %     \\[3\jot]
% %     \infer[\jrule{CUT}^B]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
% %       \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
% %   % \rightsquigarrow
% %   % \infer{\oseq{\octx |- C}}{
% %   %   \oseq{\octx |- B} & \oseq{B |- C}}
% %     & \rightsquigarrow &
% %     \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
% %       \slseq{A |- B} & \slseq{B |- C}}
% %   \end{array}
% % \end{equation*}
% % We could equally well justify this cut rule for singleton logic by first principles, as it expresses the composition of two well-formed sequents\alertinline{proofs?} in singleton logic.

\begin{figure*}[tbp]
  \captionsetup{captionskip=0pt,farskip=0pt,nearskip=0pt}
  \vspace*{-\abovecaptionskip}
  
  \begin{array}{@{}l@{}ccc@{}}
    & \text{\itshape Ordered sequent calculus} && \text{\itshape Singleton sequent calculus}
    \\
%    \subfloat[\label{fig:singleton-logic:seq-calc:derive-cut}]{\quad}
    % &
    % \infer[\mathrlap{\jrule{CUT}^B}]{\oseq{\octx'_L \oc \octx \oc \octx'_R |- C}}{
    %   \oseq{\octx |- B} & \oseq{\octx'_L \oc B \oc \octx'_R |- C}}
    % &
    % \mathrel{\phantom{\rrule{\plus}_2}\mathord{\rightsquigarrow}}
    % &
    % \infer[\mathrlap{\jrule{CUT}^B}]{\slseq{A |- C}}{
    %   \slseq{A |- B} & \slseq{B |- C}}      
    % \\
%    \subfloat[\label{fig:singleton-logic:seq-calc:derive-plus}]{\quad}
    &\!
    \begin{gathered}[t]
      \infer[\rrule{\plus}_1]{\oseq{\octx |- B_1 \plus B_2}}{
        \oseq{\octx |- B_1}}
      \quad
      \infer[\mathrlap{\rrule{\plus}_2}]{\oseq{\octx |- B_1 \plus B_2}}{
        \oseq{\octx |- B_2}}
      \\
      \infer[\mathrlap{\lrule{\plus}}]{\oseq{\octx'_L \oc (B_1 \plus B_2) \oc \octx'_R |- C}}{
        \oseq{\octx'_L \oc B_1 \oc \octx'_R |- C} &
        \oseq{\octx'_L \oc B_2 \oc \octx'_R |- C}}
    \end{gathered}
    &
    \mathrel{\phantom{\rrule{\plus}_2}\mathord{\rightsquigarrow}}
    &\!
    \begin{gathered}[t]
      \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
        \slseq{A |- B_1}}
      \quad
      \infer[\mathrlap{\rrule{\plus}_2}]{\slseq{A |- B_1 \plus B_2}}{
        \slseq{A |- B_2}}
      \\
      \infer[\mathrlap{\lrule{\plus}}]{\slseq{B_1 \plus B_2 |- C}}{
        \slseq{B_1 |- C} & \slseq{B_2 |- C}}
    \end{gathered}
  \end{array}
  \caption{Deriving the singleton sequent calculus rules for \protect\subref{fig:singleton-logic:seq-calc:derive-cut}~cut and \protect\subref{fig:singleton-logic:seq-calc:derive-plus}~additive disjunction from the corresponding ordered sequent calculus rules}\label{fig:singleton-logic:seq-calc:derive}
\end{figure*}

We could equally well justify this new cut rule by first principles, as it expresses the composition of two well-formed singleton sequents [proofs?].
But the above method of considering the constraints imposed by the single-antecedent restriction is a straightforward, mechanical way ahead for the other inference rules.
For example, singleton sequent calculus rules for additive disjunction may also be constructed in this way\parencref[see]{fig:singleton-logic:seq-calc:derive-plus}.
Rules for the other additive connectives ($\with$, $\top$, and $\zero$) can be constructed, too, but we will momentarily postpone displaying them.
% Similarly, the other additive connectives ($\with$, $\top$, and $\zero$) can be given singleton sequent calculus rules.

\newthought{%
However, not all} ordered logical connectives fare as well under the single-antecedent restriction as the additive connectives do.
In particular, the multiplicative connectives do not have analogues in singleton logic.
[In particular, the multiplicative connectives do not have analogues in singleton logic, precisely because their multiplicative nature involves splitting antecedents among several premises and, in other rules, extending the context with additional antecedents.]

\begin{marginfigure}[12\baselineskip]
  \normalsize
  \begin{gather*}
    \infer[\rrule{\limp}]{\oseq{\octx |- B_1 \limp B_2}}{
      \oseq{B_1 \oc \octx |- B_2}}
    \\
    \mathord{\downsquigarrow}\hspace{5pt}\hphantom{\rrule{\limp}}
    \\
    \infer[\rrule{\limp}\mathrlap{?}]{\slseq{A |- B_1 \limp B_2}}{
      \slseq{B_1 \oc A |- B_2}}
    \\
    \mathord{\downsquigarrow}\hspace{5pt}\hphantom{\rrule{\limp}}
    \\
    \infer[\rrule{\limp}\mathrlap{?}]{\slseq{A |- B_1 \limp B_2}}{
      \slseq{B_1 \fuse A |- B_2}}
  \end{gather*}
  \caption{A failed attempt at constructing a right rule for left-handed implication}\label{fig:singleton-logic:seq-calc:derive-limp}
\end{marginfigure}
%
Consider, for example, left-handed implication and its right rule (see neighboring \lcnamecref{fig:singleton-logic:seq-calc:derive-limp}).
% \begin{equation*}
%   \infer[\rrule{\limp}]{\oseq{\octx |- B_1 \limp B_2}}{
%     \oseq{B_1 \oc \octx |- B_2}}
% \end{equation*}
The finitary context $\octx$ must be replaced with a single antecedent, $A$, if the rule's conclusion is to be a well-formed singleton sequent.
% \begin{equation*}
%   \infer[\rrule{\limp}]{\oseq{\octx |- B_1 \limp B_2}}{
%     \oseq{B_1 \oc \octx |- B_2}}
%   \rightsquigarrow
%   \infer[\rrule{\limp}?]{\oseq{A |- B_1 \limp B_2}}{
%     \oseq{B_1 \oc A |- B_2}}
% \end{equation*}
The revised rule's conclusion is now well-formed, but its premise is not.

From a category-theoretic perspective, it would be quite natural to rewrite the premise using ordered conjunction so that the two antecedents are packaged as a single one.
% \begin{equation*}
%   \infer[\rrule{\limp}?]{\slseq{A |- B_1 \limp B_2}}{
%     \slseq{B_1 \fuse A |- B_2}}
% \end{equation*}
% 
% Viewed through a category-theoretic lens, this rule is quite innocuous, even natural.
From a proof-theoretic perspective, however, the meaning of a logical connective should be independent from other connectives, and this rule creates an objectionable dependence of left-handed implication upon ordered conjunction.
As a practical consequence, the subformula property would fail to hold and we would be unable to prove a cut elimination theorem if the singleton sequent calculus adopted this rule.

In trying to construct singleton sequent calculus rules for left-handed implication, the fundamental problem is that left-handed implication's right rule introduces an additional antecedent to a context that is, and must remain, a singleton.
Changing the size of the context by introducing, or sometimes removing, antecedents is an essential characteristic of multiplicative connectives.
So the multiplicative connectives, by their very nature, cannot appear in singleton logic.

% The left rule for left-handed implication is equally problematic:
% \begin{equation*}
%   \infer[\lrule{\limp}]{\oseq{\octx_L \oc \octx \oc (B_1 \limp B_2) \oc  \octx_R |- C}}{
%     \oseq{\octx |- B_1} & \oseq{\octx_L \oc B_2 \oc \octx_R |- C}}
%   \rightsquigarrow
%   \infer[\lrule{\limp}?]{\slseq{A \oc (B_1 \limp B_2) |- C}}{
%     \slseq{A |- B_1} & \slseq{B_2 |- C}}
% \end{equation*}

% Attempting to give singleton calculus rules for the other multiplicative connectives fails similarly.







\begin{marginfigure}
  \normalsize
  \begin{inferences}
    \infer[\lrule{\limp}?]{\slseq{A \oc (B_1 \limp B_2) |- C}}{
      \slseq{A |- B_1} & \slseq{B_2 |- C}}
  \end{inferences}
  \caption{A left rule for left-handed implication is equally problematic.}
\end{marginfigure}

% \begin{inferences}
%   \infer[\rrule{\fuse}?]{\slseq{A_1 \fuse A_2 |- B_1 \fuse B_2}}{
%     \slseq{A_1 |- B_1} & \slseq{A_2 |- B_2}}
%   \and
%   \infer[\lrule{\fuse}?]{\slseq{B_1 \fuse B_2 |- C}}{
%     \slseq{B_1 \fuse B_2 |- C}}
% \end{inferences}

% \subsection{A sequent calculus for propositional singleton logic}\label{sec:singleton-logic:seq-calc:full}

\newthought{%
\Cref{fig:singleton-logic:seq-calc}} presents the complete set of rules for propositional singleton logic's sequent calculus.
%
\begin{figure}[tbp]
  \vspace*{-\abovedisplayskip}
  \vspace*{-\abovecaptionskip}
  \begin{syntax*}
    Propositions &
      A,B,C & \alpha \mid A \plus B \mid \zero \mid A \with B \mid \top
  \end{syntax*}
  \begin{inferences}
    \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
    \and
    \infer[\jrule{ID}^A]{\slseq{A |- A}}{}
    \\
    \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_1}}
    \and
    \infer[\rrule{\plus}_2]{\slseq{A |- B_1 \plus B_2}}{
      \slseq{A |- B_2}}
    \and
    \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
      \slseq{B_1 |- C} & \slseq{B_2 |- C}}
    \\
    \text{(no $\rrule{\zero}$ rule)}
    \and
    \infer[\lrule{\zero}]{\slseq{\zero |- C}}{}
    \\
    \infer[\rrule{\with}]{\slseq{A |- B_1 \with B_2}}{
      \slseq{A |- B_1} & \slseq{A |- B_2}}
    \and
    \infer[\lrule{\with}_1]{\slseq{B_1 \with B_2 |- C}}{
      \slseq{B_1 |- C}}
    \and
    \infer[\lrule{\with}_2]{\slseq{B_1 \with B_2 |- C}}{
      \slseq{B_2 |- C}}
    \\
    \infer[\rrule{\top}]{\slseq{A |- \top}}{}
    \and
    \text{(no $\lrule{\top}$ rule)}
  \end{inferences}
  \caption{A sequent calculus for propositional singleton logic\label{fig:singleton-logic:seq-calc}}
\end{figure}
%
% The well-formed propositions are exactly the additive propositions of ordered logic, and the complete set of inference rules has been derived from those of the ordered sequent calculus by 

There are two observations to be made.
% 
First, although the propositions of singleton logic are exactly the additive propositions of ordered logic, singleton logic is \emph{not} the additive fragment of ordered logic.
For instance, the sequent $\oseq{A \oc B |- \top}$ is provable in the additive fragment of ordered logic, but it
% $\slseq{A \oc B |- \top}$
is not even a well-formed sequent in the singleton sequent calculus, for the simple reason that it violates the single-antecedent restriction.

That said, singleton logic only differs from the additive fragment of ordered logic in its treatment of $\zero$ and $\top$ -- the $\zero$,$\top$-free fragment of singleton logic coincides exactly with the $\zero$,$\top$-free additive fragment (that is, the $\plus$,$\with$-fragment) of ordered logic.
% 
% That said, the two logics are related once $\zero$ and $\top$ are excluded -- the $\zero,\top$-free fragment of singleton logic is exactly the $\zero,\top$-free additive fragment of ordered logic.
% Stated differently, the $\plus,\with$-fragment of singleton sequent calculus coincides with the $\plus,
% 
% That said, if $\top$ and $\zero$ are removed, the remainder of singleton logic is indeed exactly the $\plus,\with$-fragment of ordered logic.
A simple structural induction proves this:
\begin{theorem}
  If $\oseq{\octx |- B}$ in the $\plus,\with$-fragment of the ordered sequent calculus, then there exists a proposition $A$ such that $\octx = A$ and $\slseq{A |- B}$ in the $\plus,\with$-fragment of the singleton sequent calculus.
\end{theorem}

[Should I mention problems with $\top$ and how singleton logic sanitizes them?]

Second, as mentioned previously, singleton logic contains no multipicative connectives and, most peculiarly, no form of implication.
It is odd to contemplate that a logic without an implication connective to embody the logic's underlying hypothetical judgment could possibly be well-defined.
But as the metatheoretic results of the following \lcnamecref{sec:singleton-logic:seq-calc:metatheory} verify, singleton sequent caluculus is indeed well-defined, resting on the solid foundation of a verificationist meaning-theory.

\subsection{Metatheory: Cut elimination and identity expansion}\label{sec:singleton-logic:seq-calc:metatheory}

The rules shown in \cref{fig:singleton-logic:seq-calc} certainly have the appearance of sequent calculus rules, but do they truly constitute a well-defined sequent calculus?

In the tradition of \citeauthor{Gentzen:??}, \citeauthor{Dummett:??}, and \citeauthor{Martin-Lof:??}\autocites{Gentzen:??}{Dummett:??}{Martin-Lof:??}, a sequent calculus is well-defined if it rests on the solid foundation of a verificationist meaning-explanation.
The meaning of each logical connective must be given entirely by its right and left inference rules, and those rules must exist in harmony.

A \emph{verification}, then, is a proof that relies only on the right and left inference rules, not on the $\jrule{CUT}$ or $\jrule{ID}$ rules.

If every proof has a corresponding verification, then we can be sure that neither cut nor identity play any role in 

To show that the sequent calculus of singleton logic is well-defined, with each connective's right and left rules existing in harmony, 

In this sense, the usual cut elimination metatheorem states a weak normalization result.
%
\begin{theorem}[Cut elimination]\label{thm:singleton-logic:seq-calc:cut-elimination}
  If a proof of $\slseq{A |- C}$ exists, then there exists a cut-free proof of $\slseq{A |- C}$.
\end{theorem}
%
As usual, this \lcnamecref{thm:singleton-logic:seq-calc:cut-elimination} may be proved by a straightforward induction on the structure of the given proof, provided that a cut principle for cut-free proofs is admissible:
% 
\begin{lemma}[Admissibility of cut]\label{lem:singleton-logic:seq-calc:cut-admissibility}
  If cut-free proofs of $\slseq{A |- B}$ and $\slseq{B |- C}$ exist, then there exists a cut-free proof of $\slseq{A |- C}$.
\end{lemma}

\newthought{Before proceeding} to this \lcnamecref{lem:singleton-logic:seq-calc:cut-admissibility}'s proof, it is worth emphasizing a subtle distinction between the singleton sequent calculus's primitive $\jrule{CUT}$ rule and the admissible cut principle that this \lcnamecref{lem:singleton-logic:seq-calc:cut-admissibility} establishes.

To be completely formal, we could treat cut-freeness as an extrinsic, Curry-style property of proofs%
\footnote{Contrast this with a separate, intrinsically cut-free sequent calculus in the style of Church.\autocite{Pfenning:Andrews??}}
and indicate cut-freeness by decorating the turnstile: $\cfslseq{A |- C}$ is a cut-free proof of $\slseq{A |- C}$.
The admissible cut principle stated in \cref{lem:singleton-logic:seq-calc:cut-admissibility} could then be expressed as
\begin{equation*}
  \infer-[\jrule{A-CUT}^B]{\cfslseq{A |- C}}{
    \cfslseq{A |- B} & \cfslseq{B |- C}}
  ,
\end{equation*}
with the dotted line indicating that it is an admissible, not primitive, rule.
Writing it in this way emphasizes that the proof of \cref{lem:singleton-logic:seq-calc:cut-admissibility} amounts to defining a meta-level function that takes cut-free proofs of $\slseq{A |- B}$ and $\slseq{B |- C}$ and produces a \emph{cut-free} proof of $\slseq{A |- C}$.
% Moreover, the decorated turnstile makes it clear that all three proofs are cut-free by construction.
% 
Contrast this with the primitive $\jrule{CUT}$ rule of the singleton sequent calculus, which forms a (cut-full) proof of $\slseq{A |- C}$ from (potentially cut-full) proofs of $\slseq{A |- B}$ and $\slseq{B |- C}$.
% \footnote{Which are not necessarily cut-free.}.
\begin{marginfigure}[-4\baselineskip]
  \normalsize
  \begin{equation*}
    \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
  % \qquad\text{and}\qquad
  % \infer-[\jrule{A-CUT}^B]{\cfslseq{A |- C}}{
  %   \cfslseq{A |- B} & \cfslseq{B |- C}}
\end{equation*}
\end{marginfigure}

From here on, we won't bother to be quite so pedantic, instead often omitting the turnstile decoration on cut-free proofs with the understanding that the admissible $\jrule{A-CUT}$ rule may only be applied to cut-free proofs.

%  writing the admissible cut principle as
% \begin{equation*}
%   \infer-[\jrule{A-CUT}^B]{\slseq{A |- C}}{
%     \slseq{A |- B} & \slseq{B |- C}}
% \end{equation*}
% with the understanding that this admissible rule may only be applied to cut-free proofs.


\newthought{With that clarification}, we are finally ready to prove the admissibility of cut.

\begin{lemma}[Admissibility of cut]
  ...
\end{lemma}
%
\begin{proof}
  We follow a standard technique for proving the admissibility of a cut principle\autocite{Pfenning:CUT} -- a lexicographic induction, first on the structure of the principal cut formula, and then on the structures of the given proofs.

  As usual, the cases can be classified into three categories: principal cases, identity cases, and commutative cases.
  % We show a few sample cases.
  \begin{description}
  \item[Principal cases]
    The principal cases pair a proof ending in a right rule together with a proof ending in a corresponding left rule, so that the last inference of each proof introduces the cut formula.
    For example, one of the principal cases pairs a proof ending in the $\rrule{\plus}_1$ rule with one ending in the $\lrule{\plus}$ rule; it is resolved as follows.
    \begin{gather*}
      \infer-[\mathrlap{\jrule{A-CUT}^{B_1 \plus B_2}}]{\slseq{A |- C}}{
        \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
          \deduce{\slseq{A |- B_1}}{\DD_1}} &
        \infer[\mathrlap{\lrule{\plus}}]{\slseq{B_1 \plus B_2 |- C}}{
          \deduce{\slseq{B_1 |- C}}{\EE_1} &
          \deduce{\slseq{B_2 |- C}}{\EE_2}}}
      % 
      \\=\quad\\\quad
      % 
      \infer-[\mathrlap{\jrule{A-CUT}^{B_1}}]{\slseq{A |- C}}{
        \deduce{\slseq{A |- B_1}}{\DD_1} &
        \deduce{\slseq{B_1 |- C}}{\EE_1}}
      \qquad
    \end{gather*}
    Notice that the interaction between proofs is synchronous -- the case is resolved by appealing to the inductive hypothesis at a smaller principal type.

  
  \item[Identity cases]
    In the identity cases, one of the proofs is the $\jrule{ID}$ rule alone.
    For example, 
    % One of the identity cases pairs the $\jrule{ID}$ rule with a proof of $\slseq{A |- C}$:
    \begin{equation*}
      \infer-[\jrule{CUT}^A]{\slseq{A |- C}}{
        \infer[\jrule{ID}^A]{\slseq{A |- A}}{} &
        \deduce{\slseq{A |- C}}{\EE}}
      % 
      \quad=\quad
      % 
      \deduce{\slseq{A |- C}}{\EE}
      \,.
    \end{equation*}
    That $\jrule{CUT}$ and $\jrule{ID}$ are inverses here is consistent with the idea that cut and identity express dual principles.
    
  \item[Commutative cases]
    In the commutative cases, the last inference in one of the proofs

    The left commutative cases pair a proof of $\slseq{A |- B}$ ending in a left rule together with a proof of $\slseq{B |- C}$.
    For example, one such case
    % of the left commutative cases
    pairs a proof ending in the $\lrule{\plus}$ rule together with a proof of $\slseq{B |- C}$:
    \begin{gather*}
      \infer-[\mathrlap{\jrule{CUT}^B}]{\slseq{A_1 \plus A_2 |- C}}{
        \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- B}}{
          \deduce{\slseq{A_1 |- B}}{\DD_1} &
          \deduce{\slseq{A_2 |- B}}{\DD_2}} &
        \deduce{\slseq{B |- C}}{\EE}}
      % 
      \\=\\
      % 
      \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- C}}{
        \infer-[\jrule{CUT}^B]{\slseq{A_1 |- C}}{
          \deduce{\slseq{A_1 |- B}}{\DD_1} &
          \deduce{\slseq{B |- C}}{\EE}} &
        \infer-[\mathrlap{\jrule{CUT}^B}]{\slseq{A_2 |- C}}{
          \deduce{\slseq{A_2 |- B}}{\DD_2} &
          \deduce{\slseq{B |- C}}{\EE}}}
    \end{gather*}
    Notice that there are no left commutative cases involving right rules.

  \item[Right commutative cases]
    The right commutative cases pair a proof of $\slseq{A |- B}$ together with a proof of $\slseq{B |- C}$ ending in a right rule.
    For example, one such case
    % of the right commutative cases
    pairs a proof of $\slseq{A |- B}$ with a proof of $\slseq{B |- C_1 \plus C_2}$ ending in the $\rrule{\plus}_1$ rule:
    % ; it is resolved as follows.
    \begin{equation*}
      \infer-[\jrule{A-CUT}^B]{\slseq{A |- C_1 \plus C_2}}{
        \deduce{\slseq{A |- B}}{\DD} &
        \infer[\rrule{\plus}_1]{\slseq{B |- C_1 \plus C_2}}{
          \deduce{\slseq{B |- C_1}}{\EE_1}}}
      % 
      \quad=\quad
      % 
      \infer[\rrule{\plus}_1]{\slseq{A |- C_1 \plus C_2}}{
        \infer-[\jrule{A-CUT}^B]{\slseq{A |- C_1}}{
          \deduce{\slseq{A |- B}}{\DD} &
          \deduce{\slseq{B |- C_1}}{\EE_1}}}
    \end{equation*}
    Notice that there are no right commutative cases involving left rules because the sequent $\slseq{B |- C}$ contains only the principal antecedent.
    In this way, the proof of admissibility of cut for singleton logic is more symmetric than that of ordered logic.
    There, several right commutative cases involved left rules acting on non-principal antecedents.
    \qedhere
  \end{description}
\end{proof}


With the admissibility of cut established, we can finally prove cut elimination for the singleton sequent calculus.
%
\begin{theorem}[Cut elimination]
  If a proof of $\slseq{A |- C}$ exists, then a cut-free proof of $\slseq{A |- C}$ exists.
\end{theorem}
%
\begin{proof}
  By structural induction on the proof of $\slseq{A |- C}$, appealing to the admissibility of cut\parencref{lem:singleton-logic:seq-calc:cut-admissibility} when encountering a $\jrule{CUT}$ rule.

  If we display the inductive hypothesis as an admissible rule, then the crucial case in the proof of cut elimination is resolved as follows.
  \begin{equation*}
    \infer-[\jrule{CE}]{\cfslseq{A |- C}}{
      \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
        \deduce{\slseq{A |- B}}{\DD_1} & \deduce{\slseq{B |- C}}{\DD_2}}}
    \quad=\quad
    \infer-[\jrule{A-CUT}^B]{\cfslseq{A |- C}}{
      \infer-[\jrule{CE}]{\cfslseq{A |- B}}{
        \deduce{\slseq{A |- B}}{\DD_1}} &
      \infer-[\jrule{CE}]{\cfslseq{B |- C}}{
        \deduce{\slseq{B |- C}}{\DD_2}}}
  \end{equation*}
  All other cases are handled compositionally.

  Notice that this proof amounts to defining a meta-level function for normalizing proofs to cut-free form.
\end{proof}

\begin{theorem}[Identity expansion]
  $\slseq{A |- A}$ for all propositions $A$.
\end{theorem}
%
\begin{proof}
  By induction on the structure of the proposition $A$.
  % \begin{gather*}
  %   \infer-[\mathrlap{\jrule{ID}^{A_1 \plus A_2}}]{\slseq{A_1 \plus A_2 |- A_1 \plus A_2}}{}
  %   \\=\\
  %   \infer[\mathrlap{\lrule{\plus}}]{\slseq{A_1 \plus A_2 |- A_1 \plus A_2}}{
  %     \infer[\rrule{\plus}_1]{\slseq{A_1 |- A_1 \plus A_2}}{
  %       \infer-[\jrule{ID}^{A_1}]{\slseq{A_1 |- A_1}}{}} &
  %     \infer[\mathrlap{\rrule{\plus}_2}]{\slseq{A_2 |- A_1 \plus A_2}}{
  %       \infer-[\mathrlap{\jrule{ID}^{A_2}}]{\slseq{A_2 |- A_2}}{}}}
  % \end{gather*}
\end{proof}


\section{A Hilbert-style axiomatization of singleton logic}\label{sec:singleton-logic:hilbert}

Sequent calculi are not the only way to present logics, so
% natural deduction calculi and Hilbert systems are also commonly used, for instance.
in this \lcnamecref{sec:singleton-logic:hilbert} we also consider a Hilbert-style axiomatization of singleton logic.
Our interest in a Hilbert system for singleton logic is not zoological, however.
Rather, over the course of the next \lcnamecref{ch:singleton-processes} and a half, we shall see that weak normalization of Hilbert-style proofs serves as the basis of a Curry--Howard isomorphism with chains of asynchronously communicating processes.

% \subsection{A Hilbert-style axiomatization of linear logic}

\newthought{In a se{q}uent calculus}, the meaning of a connective is given by its right and left inference rules.
Hilbert-style axiomatizations, on the other hand, strive to use as few rules of inference as possible, with the meaning of a connective instead given by a small collection of axioms.

To avoid unnecessarily introducing rules of inference,
% Most of the time,
these axioms rely heavily on implication and a \textit{modus ponens} rule to effect ... 

Central to this endeavor is often a deduction theorem which shows that implication embodies the logic's underlying hypothetical judgement as a logical connective.
For example, a Hilbert-style axiomatization of intuitionistic ordered logic would enjoy a deduction theorem involving left- and right-handed implications:
\begin{theorem*}
  $\oseq{A \oc \octx |- B}$ if and only if $\oseq{\octx |- A \limp B}$.
  Similarly, $\oseq{\octx \oc A |- B}$ if and only if $\oseq{\octx |- B \pmir A}$.
\end{theorem*}

To avoid unnecessarily introducing rules of inference,
% Most of the time,
these axioms rely heavily on implication and a \textit{modus ponens} rule to effect ... 
For example, in a Hilbert-style axiomatization of intuitionistic ordered logic\autocite{Avron:??}, ordered conjunction is described by the following axioms.
\begin{equation*}
  \begin{lgathered}
    \vdash B \limp (A \limp A \fuse B) \\
    \vdash (B \limp (A \limp C)) \limp (A \fuse B \limp C)
  \end{lgathered}
\end{equation*}
The axioms are suggestive of the right and left sequent calculus rules for 
\begin{equation*}
  \begin{lgathered}
    \vdash A \lolli B \lolli A \tensor B \\
    \vdash (A \lolli B \lolli C) \lolli (A \tensor B \lolli C)
  \end{lgathered}
  \quad\rightsquigarrow\quad
  \begin{gathered}
    \infer{A , B \vdash A \tensor B}{} \\
    \infer{A \tensor B \vdash C}{
      A, B \vdash C}
  \end{gathered}
\end{equation*}



% Whereas sequent calculi use many inference rules but few axioms, Hilbert systems shift the balance far in favor of axioms.


% In a Hilbert system, each logical connective is defined by a collection of axioms.
% For example, in a Hilbert system for intuitionistic ordered logic, additive disjunction would be defined by three axioms:
\begin{equation*}
  \begin{lgathered}
    \infer[\with]{\vdash A \with B}{
      \vdash A & \vdash B}
    \\
    \vdash \bigl((A \limp B_1) \with (A \limp B_2)\bigr) \limp (A \limp B_1 \with B_2)
  \end{lgathered}
  \qquad
  \begin{lgathered}[b]
    \vdash A_1 \with A_2 \limp A_1 \\
    \vdash A_1 \with A_2 \limp A_2
  \end{lgathered}
\end{equation*}


% \newcommand*{\approxident}{%
%   \mathrel{\vcenter{\offinterlineskip
%   \hbox{$\sim$}\vskip-.35ex\hbox{$\sim$}\vskip-.35ex\hbox{$\sim$}}}}

% % For reasons better explained in future \lcnamecrefs{ch:singleton-logic}, we need a Curry--Howard interpretation of singleton logic as a session-type system for asynchronous processes.

% Notice that there is more than one way to extend a proof of $\slseq{A |- B_1}$ to a proof of $\slseq{A |- B_1 \plus B_2}$.
% Of course, the most obvious way is to simply apply the $\rrule{\plus}_1$ rule to the given proof.
% Another, less direct way is to cut the given proof against an identity embellished with the $\rrule{\plus}_1$ rule.
% \begin{equation*}
%   \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1}}
%   \qquad\text{and}\qquad
%   \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1} &
%     \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus }}{
%       \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}}
% \end{equation*}
% In fact, these proofs do not merely conclude with the same sequent -- these proofs are related by cut reduction:
% \begin{equation*}
%   \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1} &
%     \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%       \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}}
%   \longrightarrow\longrightarrow\enspace
%   \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1}}
% \end{equation*}
% This suggests that the $\rrule{\plus}_1$-embellished identity may be worthy of special consideration.

% Suppose that we replace the usual $\rrule{\plus}_1$ rule with a new primitive rule that collapses the embellished identity.
% \begin{equation*}
%   \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%     \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}
%   \rightsquigarrow
%   \infer[\rrule{\plus}_1']{\slseq{B_1 |- B_1 \plus B_2}}{}
% \end{equation*}


% \begin{gather*}
%   \infer[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
%     \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
%       \slseq{A |- B_1} &
%       \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%         \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}} &
%     \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
%       \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
%   \\\equiv\\
%   \infer[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
%     \slseq{A |- B_1} &
%     \infer[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{B_1 |- C}}{
%       \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%         \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}} &
%       \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
%         \slseq{B_1 |- C} & \slseq{B_2 |- C}}}}
%   \\\longrightarrow\longrightarrow\\
%   \infer[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
%     \slseq{A |- B_1} & \slseq{B_1 |- C}}
% \end{gather*}

% \begin{gather*}
%   \infer[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
%     \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
%       \slseq{A |- B_1}} &
%     \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
%       \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
%   \\\longrightarrow\\
%   \infer[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
%     \slseq{A |- B_1} & \slseq{B_1 |- C}}
% \end{gather*}


% \begin{equation*}
%   \selectR{\kay}[P]
%   \approxident
%   \spawn{P}{(\selectR{\kay}[\fwd])}
% \end{equation*}

% \begin{marginfigure}
%   \begin{gather*}
%     \infer[\rrule{\plus}_1]{\slof{A |- \selectR{\kay}[P] : B_1 \plus B_2}}{
%       \slseq{A |- P : B_1}}
%     \\\approxident\\
%     \infer[\jrule{CUT}^{B_1}]{\slseq{A |- \spawn{P}{(\selectR{\kay}[\fwd])} : B_1 \plus B_2}}{
%       \slseq{A |- P : B_1} &
%       \infer[\rrule{\plus}_1]{\slseq{B_1 |- \selectR{\kay}[\fwd] : B_1 \plus B_2}}{
%         \infer[\jrule{ID}]{\slseq{B_1 |- \fwd : B_1}}{}}}
%   \end{gather*}
%   \caption{}
% \end{marginfigure}


  
% \begin{gather*}
%   \begin{lgathered}
%     \spawn{(\selectR{\kay}[P])}{\caseL[\ell \in L]{\ell => Q_{\ell}}}
%       \longrightarrow \spawn{P}{Q_{\kay}}
%     \\
%     \begin{aligned}
%       \MoveEqLeft[.5]
%       \spawn{\bigl(\spawn{P}{(\selectR{\kay}[\fwd])}\bigr)}{\caseL[\ell \in L]{\ell => Q_{\ell}}} \\[-.75\jot]
%         &\equiv \spawn{P}{\bigl(\spawn{(\selectR{\kay}[\fwd])}{\caseL[\ell \in L]{\ell => Q_{\ell}}}\bigr)} \\[-.75\jot]
%         % &\longrightarrow \spawn{P}{(\spawn{\fwd}{Q_{\kay}})} \\[-.75\jot]
%         &\longrightarrow\longrightarrow \spawn{P}{Q_{\kay}}
%     \end{aligned}
%   \end{lgathered}
% \end{gather*}

% % \begin{gather*}
% %   \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
% %     \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
% %       \slseq{A |- B_1}} &
% %     \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
% %       \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
% %   =
% %   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
% %     \slseq{A |- B_1} & \slseq{B_1 |- C}}
% %   \\=\\
% %   \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{A |- C}}{
% %     \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
% %       \slseq{A |- B_1} &
% %       \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
% %         \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}} &
% %     \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
% %       \slseq{B_1 |- C} & \slseq{B_2 |- C}}}
% %   \equiv
% %   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
% %     \slseq{A |- B_1} &
% %     \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{B_1 |- C}}{
% %       \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
% %         \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}} &
% %       \infer[\lrule{\plus}]{\slseq{B_1 \plus B_2 |- C}}{
% %         \slseq{B_1 |- C} & \slseq{B_2 |- C}}}}
% %   \\=\\
% %   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
% %     \slseq{A |- B_1} &
% %     \infer-[\jrule{CUT}^{B_1 \plus B_2}]{\slseq{B_1 |- C}}{
% %       \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{} &
% %       \slseq{B_1 |- C}}}
% %   \\=\\
% %   \infer-[\jrule{CUT}^{B_1}]{\slseq{A |- C}}{
% %     \slseq{A |- B_1} & \slseq{B_1 |- C}}
% % \end{gather*}


% \begin{equation*}
%   \infer[\rrule{\plus}_1]{\slseq{B_1 |- B_1 \plus B_2}}{
%     \infer[\jrule{ID}]{\slseq{B_1 |- B_1}}{}}
%   \leftrightsquigarrow
%   \infer[\rrule{\plus}_1']{\slseq{B_1 |- B_1 \plus B_2}}{}
% \end{equation*}


% \begin{equation*}
%   \infer[\rrule{\plus}_1]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1}}
%   \leftrightsquigarrow
%   \infer[\jrule{CUT}^{B_1}]{\slseq{A |- B_1 \plus B_2}}{
%     \slseq{A |- B_1} &
%     \infer[\rrule{\plus}_1']{\slseq{B_1 |- B_1 \plus B_2}}{}}
% \end{equation*}


% \begin{equation*}
%   \infer-[\jrule{CUT}^{A_1}]{\slseq{A_1 |- C}}{
%     \infer[\rrule{\plus}_1']{\slseq{A_1 |- A_1 \plus A_2}}{} &
%     \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- C}}{
%       \deduce{\slseq{A_1 |- C}}{\EE_1} &
%       \deduce{\slseq{A_2 |- C}}{\EE_2}}}
%   \rightsquigarrow
%   \deduce{\slseq{A_1 |- C}}{\EE_1}
% \end{equation*}



\begin{inferences}
  \infer[\jrule{MP}]{\slseq{|- C}}{
    \slseq{|- B} & \slseq{|- B \limp C}}
  \\
  \begin{lgathered}
  \vdash A \limp A
  \\
  \vdash A_1 \limp A_1 \plus A_2 \\
  \vdash A_2 \limp A_1 \plus A_2 \\
  \vdash (A_2 \limp C) \limp (A_1 \limp C) \limp (A_1 \plus A_2 \limp C)
\end{lgathered}
\end{inferences}




\begin{figure}
  \begin{syntax*}
    Propositions &
      A & \alpha \mid A \plus B \mid \zero \mid A \with B \mid \top
  \end{syntax*}
  \begin{inferences}
    \infer[\jrule{CUT}^B]{\slseq{A |- C}}{
      \slseq{A |- B} & \slseq{B |- C}}
    \and
    \infer[\jrule{ID}^A]{\slseq{A |- A}}{}
    \\
    \infer[\rrule{\plus}_1']{\slseq{A_1 |- A_1 \plus A_2}}{}
    \and
    \infer[\rrule{\plus}_2']{\slseq{A_2 |- A_1 \plus A_2}}{}
    \and
    \infer[\lrule{\plus}]{\slseq{A_1 \plus A_2 |- C}}{
      \slseq{A_1 |- C} & \slseq{A_2 |- C}}
    \\
    \text{(no $\rrule{\zero}$ rule)}
    \and
    \infer[\lrule{\zero}]{\slseq{\zero |- C}}{}
    \\
    \infer[\rrule{\with}]{\slseq{A |- C_1 \with C_2}}{
      \slseq{A |- C_1} & \slseq{A |- C_2}}
    \and
    \infer[\lrule{\with}_1']{\slseq{C_1 \with C_2 |- C_1}}{}
    \and
    \infer[\lrule{\with}_2']{\slseq{C_1 \with C_2 |- C_2}}{}
    \\
    \infer[\rrule{\top}]{\slseq{A |- \top}}{}
    \and
    \text{(no $\lrule{\top}$ rule)}
  \end{inferences}
  
  \caption{A Hilbert system for singleton logic\label{fig:singleton-logic:hilbert}}
\end{figure}

The Hilbert system of \cref{fig:singleton-logic:hilbert} can also be viewed as a variant of the singleton sequent calculus\parencref{fig:singleton-logic:seq-calc} in which each connective's non-invertible rules have been replaced with zero-premise rules.
As such, we should seek to prove the usual sequent calculus metatheorems -- cut elimination and identity expansion -- for this Hilbert-style variant.

Strictly speaking, cut elimination does not hold for this calculus.
As a concrete counterexample, there is no cut-free Hilbert-style proof of $\slseq{\alpha_2 |- \alpha_1 \plus (\alpha_2 \plus \alpha_3)}$, even though the same sequent is provable using cut:
\begin{equation*}
  \infer[\jrule{CUT}]{\slseq{\alpha_2 |- \alpha_1 \plus (\alpha_2 \plus \alpha_3)}}{
    \infer[\rrule{\plus}'_1]{\slseq{\alpha_2 |- \alpha_2 \plus \alpha_3}}{} &
    \infer[\rrule{\plus}'_2]{\slseq{\alpha_2 \plus \alpha_3 |- \alpha_1 \plus (\alpha_2 \plus \alpha_3)}}{}}
\end{equation*}
Although cut elimination does not hold, proofs are nevertheless normalizable.
% , we will still be able to prove a weak normalization result.
Normal proofs will still contain cuts, but those cuts will be of a particular, analytic form.
In other words, although full cut elimination does not hold,
% of all cuts is not possible, but
\emph{non-analytic} cut elimination does.

Before presenting a proof of non-analytic cut elimination, we will take a moment to introduce proof terms for the Hilbert system.
These proof terms will be a convenient, succinct notation with which to describe the elimination procedure.

To keep the proof terms compact, we will also take this opportunity to replace the binary forms of additive disjunction and conjunction with labeled, $n$-ary forms.

This way, normal proofs are analytic that admits a subformula property and therefore count as verifications.

\begin{figure}[t]
\begin{syntax*}
  Propositions &
    A & \alpha \mid \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}
               \mid \with*[sub=_{\ell \in L}]{\ell:A_{\ell}}
  \\
  Proof terms &
    P & % \begin{array}[t]{@{}l@{}}
          \spawn{P_1}{P_2} \mid \fwd
          \begin{array}[t]{@{{} \mid {}}l@{}}
            \selectR{\kay} \mid \caseL[\ell \in L]{\ell => P_{\ell}} \\
            \caseR[\ell \in L]{\ell => P_{\ell}} \mid \selectL{\kay}
          \end{array}
        % \end{array}
\end{syntax*}
\begin{inferences}
  \infer[\jrule{CUT}^B]{\slseq{A |- \spawn{P_1}{P_2} : C}}{
    \slseq{A |- P_1 : B} & \slseq{B |- P_2 : C}}
  \and
  \infer[\jrule{ID}^A]{\slseq{A |- \fwd : A}}{}
  \\
  \infer[\rrule{\plus}']{\slseq{A_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}}}{
    \text{($\kay \in L$)}}
  \and
  \infer[\lrule{\plus}]{\slseq{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} |- \caseL[\ell \in L]{\ell => P_{\ell}} : C}}{
    \multipremise{\ell \in L}{\slseq{A_{\ell} |- P_{\ell} : C}}}
  \\
  \infer[\rrule{\with}]{\slseq{A |- \caseR[\ell \in L]{\ell => P_{\ell}} : \with*[sub=_{\ell \in L}]{\ell:C_{\ell}}}}{
    \multipremise{\ell \in L}{\slseq{A |- P_{\ell} : C_{\ell}}}}
  \and
  \infer[\lrule{\with}']{\slseq{\with*[sub=_{\ell \in L}]{\ell:C_{\ell}} |- \selectL{\kay} : C_{\kay}}}{
    \text{($\kay \in L$)}}
\end{inferences}
  \caption{Proof terms for a labeled variant of the Hilbert system of \cref{fig:singleton-logic:hilbert}}%
  \label{fig:singleton-logic:hilbert-terms}
\end{figure}


\subsection{Non-analytic cut elimination for the singleton Hilbert system}

With proof terms in hand, we can now return to our goal of establishing a \emph{non-analytic} cut elimination result for the singleton Hilbert system.

\begin{marginfigure}
  \begin{gather*}
    \infer[\jrule{CUT}^{A_{\kay}}]{\slof{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} |- \spawn{\selectL{\kay}}{P} : C}}{
      \infer[\lrule{\with}']{\slof{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} |- \selectL{\kay} : A_{\kay}}}{
        \text{($\kay \in L$)}} &
      \slof{A_{\kay} |- P : C}}
    \\[2\jot]
    \infer[\jrule{CUT}^{C_{\kay}}]{\slof{A |- \spawn{P}{\selectR{\kay}} : \plus*[sub=_{\ell \in L}]{\ell:C_{\ell}}}}{
      \slof{A |- P : C_{\kay}} &
      \infer[\rrule{\plus}']{\slof{C_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:C_{\ell}}}}{
        \text{($\kay \in L$)}}}
  \end{gather*}
  \caption{Analytic forms of cut}\label{fig:singleton-logic:hilbert:analytic-cuts}
\end{marginfigure}
%
The elimination procedure will normalize a Hilbert-style proof so that any remaining cuts are of the form $\spawn{\selectL{\kay}}{P}$ or $\spawn{P}{\selectR{\kay}}$.
As shown in \cref{fig:singleton-logic:hilbert:analytic-cuts}, cuts of these forms are analytic because the principal formula is a subformula
%



\begin{syntax*}
  Normal terms &
    N,M & \begin{array}[t]{@{}l@{}}
            \fwd \mid \spawn{N}{\selectR{\kay}} \mid \spawn{\selectL{\kay}}{N} \\
            \begin{array}[t]{@{\mathllap{\mid {}}}l@{}}
              \selectR{\kay} \mid \caseL[\ell \in L]{\ell => N_{\ell}} \\
              \caseR[\ell \in L]{\ell => N_{\ell}} \mid \selectL{\kay}
            \end{array}
          \end{array}
\end{syntax*}


\begin{theorem}[Non-analytic cut elimination]
  If $\slof{A |- P : C}$, then $\slof{A |- N : C}$ for some normal term $N$.
\end{theorem}



\begin{lemma}[Admissibility of non-analytic cut]\label{lem:singleton-logic:hilbert:cut-admissibility}
  If $\slof{A |- N : B}$ and $\slof{B |- M : C}$, then $\slof{A |- N' : C}$ for some normal term $N'$.
\end{lemma}
%
\begin{proof}
  As with \cref{lem:singleton-logic:seq-calc:cut-admissibility} for the sequent calculus, this \lcnamecref{lem:singleton-logic:hilbert:cut-admissibility} states the admissibility of a cut principle, and its proof amounts to the definition of a meta-level function on proofs.
  However, with proof terms, we can now make the function definition more apparent.

  Let $\nspawn{}{}$ be a binary function on normal terms $N$ and $M$ of compatible types such that $\nspawn{N}{M}$ is a normal term of the corresponding type:
  % We will define $\nspawn{}{}$ as a meta-level function from pairs of normal terms of compatible types to normal terms of the corresponding type.
  \begin{equation*}
    \infer-[\jrule{A-CUT}^B]{\slof{A |- \nspawn{N}{M} : C}}{
      \slof{A |- N : B} & \slof{B |- M : C}}
    \,.
  \end{equation*}

  Once again, the cut principle can be proved by a lexicographic induction, first on the principal type, $B$, and then on the structures of the given terms, $N$ and $M$.
  However, because the Hilbert system uses different rules than the sequent calculus, the proof's cases are organized a bit differently.
  In addition to the usual classes of principal, identity, left commutative, and right commutative cases, a new class of associative cases is introduced.
  \begin{description}[listparindent=\parindent, parsep=0pt]
  \item[Associative cases]
    Consider, for example, the case $\nspawn{(\spawn{N_0}{\selectR{\kay}})}{M}$.
    Because the term $\selectR{\kay}$ is itself normal, the above term can be reassociated, suggesting that we adopt 
    \begin{equation*}
      \nspawn{(\spawn{N_0}{\selectR{\kay}})}{M}
        = \nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})}
    \end{equation*}
    as a clause in the definition of $\nspawn{}{}$.
    But is this clause terminating?

    Yes, indeed it is.
    In $\nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})}$, the inner $\nspawn{\selectR{\kay}}{M}$ terminates because the terms have become smaller -- $\selectR{\kay}$ is a proper subterm of $\spawn{N_0}{\selectR{\kay}}$ -- while the principal type remains unchanged.
    The outer $\nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})}$ also terminates, despite $\nspawn{\selectR{\kay}}{M}$ possibly being larger than $M$, because the principal type has become smaller.%
    \footnote{To aid the reader in tracking the types, \cref{fig:singleton-logic:hilbert:associative-cut} shows the full typing derivations.}
    \begin{figure*}[tbp]
      \begin{gather*}
        \infer-[\jrule{A-CUT}^B]{\slof{A |- \nspawn{(\spawn{N_0}{\selectR{\kay}})}{M} : C}}{
          \infer[\jrule{CUT}^{B_{\kay}}]{\slof{A |- \spawn{N_0}{\selectR{\kay}} : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
            \slof{A |- N_0 : B_{\kay}} &
            \infer[\rrule{\plus}']{\slof{B_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
              \text{($\kay \in L$)}}} &
          \slof{\plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- M : C}}
        \\=\\
        \infer-[\jrule{A-CUT}^{B_{\kay}}]{\slof{A |- \nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})} : C}}{
          \slof{A |- N_0 : B_{\kay}} &
          \infer-[\jrule{A-CUT}^B]{\slof{B_{\kay} |- \nspawn{\selectR{\kay}}{M} : C}}{
            \infer[\rrule{\plus}']{\slof{B_{\kay} |- \selectR{\kay} : \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}}{
              \text{($\kay \in L$)}} &
            \slof{\plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- M : C}}}
      \end{gather*}
      \caption{One of the associative cases in the proof of non-analytic cut admissibility\parencref{lem:singleton-logic:hilbert:associative-cut}}\label{fig:singleton-logic:hilbert:associative-cut}
    \end{figure*}

    The symmetric case, $\nspawn{N}{(\spawn{\selectL{\kay}}{M_0})}$, is also an associative case and is handled similarly.
    The complete set of associative clauses is therefore:
    \begin{gather*}
      \nspawn{(\spawn{N_0}{\selectR{\kay}})}{M} = \nspawn{N_0}{(\nspawn{\selectR{\kay}}{M})} \\
      \nspawn{N}{(\spawn{\selectL{\kay}}{M_0})} = \nspawn{(\nspawn{N}{\selectL{\kay}})}{M_0}
    \end{gather*}
    Both of these associative cases detach a label and group it together with the neighboring term, thereby enabling interactions between the label and term.

\item[Principal cases]
  Because the above associative cases decompose the analytic cuts $\spawn{N_0}{\selectR{\kay}}$ and $\spawn{\selectL{\kay}}{M_0}$, the principal cases need only cover those pairings of the $\rrule{\plus}'$ rule with a proof ending in the $\lrule{\plus}$ rule and the symmetric pairings involving the $\rrule{\with}$ and $\lrule{\with}'$ rules:
  \begin{gather*}
    \nspawn{\selectR{\kay}}{\caseL[\ell \in L]{\ell => M_{\ell}}} = M_{\kay} \\
    \nspawn{\caseR[\ell \in L]{\ell => N_{\ell}}}{\selectL{\kay}} = N_{\kay}
  \end{gather*}
  If $\selectR{\kay}$ and $\selectL{\kay}$ are viewed as directed messages, then these principal clauses in $\nspawn{}{}$'s definition look much like rules for asynchronous message-passing communication.
  This observation is at the heart of the Curry--Howard interpretation of the singleton Hilbert system that we develop in the following \lcnamecref{ch:singleton-procs}.

\item[Identity cases]
  As in the proof of admissibility of cut for the sequent calculus\parencref{lem:singleton-logic:seq-calc:cut-admissibility}, the identity cases cover pairings involving the $\jrule{ID}$ rule and yield the following clauses.
  \begin{gather*}
    \nspawn{\fwd}{M} = M \\
    \nspawn{N}{\fwd} = N
  \end{gather*}


\item[Left commutative cases]
  
  \begin{gather*}
    \nspawn{(\spawn{\selectL{\kay}}{N_0})}{M} = \spawn{\selectL{\kay}}{(\nspawn{N_0}{M})} \\
    \nspawn{\selectL{\kay}}{M} = \spawn{\selectL{\kay}}{M} \\
    \nspawn{\caseL[\ell \in L]{\ell => N_{\ell}}}{M} =
      \begin{array}[t]{@{}l@{}}
        \caseL[\ell \in L]{\ell => \nspawn{N_{\ell}}{M}} \mathrlap{\,,} \\
        \mathrlap{\quad\text{if $M \neq \selectR{\kay}$ and $M \neq \spawn{M_0}{\selectR{\kay}}$ for all $M_0$}}
      \end{array}
  \end{gather*}
  Without this side condition, the grammar of normal terms would include reducible terms like $\spawn{\caseL[\ell \in L]{\ell => N_{\ell}}}{\selectR{\kay}}$.

\item[Right commutative cases]
  There are several right commutative cases that are symmetric to the preceding left commutative cases.
  \begin{gather*}
    \nspawn{N}{(\spawn{M_0}{\selectR{\kay}})} = \spawn{(\nspawn{N}{M_0})}{\selectR{\kay}} \\
    \nspawn{N}{\selectR{\kay}} = \spawn{N}{\selectR{\kay}} \\
    \nspawn{N}{\caseR[\ell \in L]{\ell => M_{\ell}}} =
      \begin{array}[t]{@{}l@{}}
        \caseR[\ell \in L]{\ell => \nspawn{N}{M_{\ell}}} \mathrlap{\,,} \\
        \mathrlap{\quad\text{if $N \neq \selectL{\kay}$ and $N \neq \spawn{\selectL{\kay}}{N_0}$ for all $N_0$}}
      \end{array}
  \end{gather*}

\end{description}

\end{proof}

\begin{theorem}
  If $\slof{A |- P : C}$, then $\slof{A |- N : C}$ for some normal term $N$.
\end{theorem}
\begin{proof}
  \begin{equation*}
    \infer-[\jrule{CE}]{\slof{A |- \wn{P} : C}}{
      \slof{A |- P : C}}
  \end{equation*}

  \begin{equation*}
    \infer-[\jrule{CE}]{\slof{A |- \wn{\spawn{P_1}{P_2}} : C}}{
      \infer[\jrule{CUT}^B]{\slof{A |- \spawn{P_1}{P_2} : C}}{
        \slof{A |- P_1 : B} & \slof{B |- P_2 : C}}}
    =
    \infer-[\jrule{A-CUT}^B]{\slof{A |- \nspawn{\wn{P_1}}{\wn{P_2}} : C}}{
      \infer-[\jrule{CE}]{\slof{A |- \wn{P_1} : C}}{
        \slof{A |- P_1 : B}} &
      \infer-[\jrule{CE}]{\slof{B |- \wn{P_2} : C}}{
        \slof{B |- P_2 : C}}}
  \end{equation*}

  \begin{equation*}
    \begin{lgathered}
      \wn{\spawn{P_1}{P_2}} = \nspawn{\wn{P_1}}{\wn{P_2}} \\
      \wn{\fwd} = \fwd \\
      \wn{\selectR{\kay}} = \selectR{\kay} \\
      \wn{\caseL[\ell \in L]{\ell => P_{\ell}}} = \caseL[\ell \in L]{\ell => \wn{P_{\ell}}} \\
      \wn{\caseR[\ell \in L]{\ell => P_{\ell}}} = \caseR[\ell \in L]{\ell => \wn{P_{\ell}}} \\
      \wn{\selectL{\kay}} = \selectL{\kay}
    \end{lgathered}
  \end{equation*}
\end{proof}




\begin{description}
\end{description}

% \subsection{Operational semantics}

% \begin{syntax*}
%   Configurations & \cnf & \cnf_1 \cc \cnf_2 \mid \cnfe \mid P
% \end{syntax*}

% \begin{equation*}
%   \begin{gathered}
%     \!\begin{aligned}
%       \fwd &\reduces \cdot \\
%       \spawn{P_1}{P_2} &\reduces P_1 \cc P_2
%     \end{aligned} \\
%     \selectR{\kay} \cc \caseL[\ell \in L]{\ell => P_{\ell}}
%       \reduces P_{\kay} \\
%     \caseR[\ell \in L]{\ell => P_{\ell}} \cc \selectL{\kay}
%       \reduces P_{\kay}
%     \\[2\jot]
%     \cnf \cc \cnfe = \cnf = \cnfe \cc \cnf \\
%     (\cnf_1 \cc \cnf_2) \cc \cnf_3 = \cnf_1 \cc (\cnf_2 \cc \cnf_3)
%   \end{gathered}
% \end{equation*}

% \begin{equation*}
%   \begin{aligned}
%     (\cnf_1 \cc \cnf_2)^\sharp &= \spawn{\cnf_1^\sharp}{\cnf_2^\sharp} \\
%     (\cnfe)^\sharp &= \fwd \\
%     P^\sharp &= P
%   \end{aligned}
% \end{equation*}


\subsection{$\eta$-expansion}

\begin{align*}
  \eta(\alpha) &= \fwd \\
  \eta(\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}) &= \caseL[\ell \in L]{\ell => \selectR{\ell}} \\
  \eta(\with*[sub=_{\ell \in L}]{\ell:A_{\ell}}) &= \caseR[\ell \in L]{\ell => \selectL{\ell}}
\end{align*}

\begin{align*}
  \mathit{ie}(\slof{A |- \spawn{P_1}{P_2} : C}) &= \spawn{\mathit{ie}(\slof{A |- P_1 : B})}{\mathit{ie}(\slof{B |- P_2 : C})} \\
  \mathit{ie}(\slof{A |- \fwd : A}) &= \eta(A) \\
\end{align*}


\section{Extensions of singleton logic}\label{sec:singleton-logic:extensions}

The singleton sequent calculus and singleton Hilbert system support various extensions.
One simple but useful extension is to introduce universal and existential quantifiers, $\forall x{:}\tau.A$ and $\exists x{:}\tau.A$, over well-sorted data.
Variables $x$ are not subject to the single-antecedent restriction.

\newthought{Another direction} is to slightly relax the single-antecedent restriction.
instead of demanding that sequents have exactly one antecedent and exactly one consequent, we might allow each sequent to have zero or one antecedents and zero or one consequents.
So now, instead of sequents $\slseq{A |- C}$, we have sequents $\slseq{\sctx |- \cseq}$, where $\sctx$ and $\cseq$ adhere to the following grammars.

\begin{itemize}
\item Multiplicative units (subsingletons)
\item Exponentials
\end{itemize}

\begin{syntax*}
  Propositions & A & \dotsb \mid \one \\
  Contexts & \sctx & A \mid \sctxe
\end{syntax*}

\begin{inferences}
  \infer[\rrule{\one}]{\slseq{\sctxe |- \one}}{}
  \and
  \infer[\lrule{\one}]{\slseq{\one |- C}}{
    \slseq{\sctxe |- C}}
\end{inferences}

\begin{syntax*}
  Propositions & A & \dotsb \mid \bot \\
  Conseq\relax uents & \cseq & C \mid \cseqe
\end{syntax*}

\begin{inferences}
  \infer[\rrule{\bot}]{\slseq{\sctx |- \bot}}{
    \slseq{\sctx |- \cseqe}}
  \and
  \infer[\lrule{\bot}]{\slseq{\bot |- \cseqe}}{}
\end{inferences}

\begin{syntax*}
  Propositions & A & \dotsb \mid \bang A \\
  Persistent contexts & \uctx & \uctxe \mid \uctx, A
\end{syntax*}

\begin{inferences}
  \infer[\jrule{CUT!}^A]{\slseq{\uctx, A ; \sctx |- \cseq}}{
    \slseq{\uctx ; \sctxe |- A} & \slseq{\uctx, A ; \sctx |- \cseq}}
  \and
  \infer[\jrule{COPY}]{\slseq{\uctx, A ; \sctxe |- \cseq}}{
    \slseq{\uctx, A ; A |- \cseq}}
  \\
  \infer[\rrule{\bang}]{\slseq{\uctx ; \sctxe |- \bang A}}{
    \slseq{\uctx ; \sctxe |- A}}
  \and
  \infer[\lrule{\bang}]{\slseq{\uctx ; \bang A |- \cseq}}{
    \slseq{\uctx, A ; \sctxe |- \cseq}}
\end{inferences}

\begin{inferences}
  \infer[\rrule{\bang\tensor}]{\slseq{\uctx ; \sctx |- A_1 \mathbin{\bang\tensor} A_2}}{
    \slseq{\uctx ; \sctxe |- A_1} & \slseq{\uctx ; \sctx |- A_2}}
  \and
  \infer[\lrule{\bang\tensor}]{\slseq{\uctx ; A_1 \mathbin{\bang\tensor} A_2 |- \cseq}}{
    \slseq{\uctx, A_1 ; A_2 |- \cseq}}
\end{inferences}

\begin{inferences}
  \infer[\rrule{\bang}]{\slseq{\uctx, A ; \sctxe |- \bang A}}{}
  \and
  \infer[\rrule{\bang\tensor}]{\slseq{\uctx, A_1 ; A_2 |- A_1 \mathbin{\bang\tensor} A_2}}{}
\end{inferences}


\section{Related work}\label{sec:singleton-logic:related-work}

\begin{itemize}
\item Fortier and Santocanale paper using (synchronous) singleton logic
\item CSL '12 paper on asynchronous Curry--Howard for linear logic
\end{itemize}


\section{Hilbert}

\subsection{Hypothetical Hilbert system}

\NewDocumentCommand{\hil}{}{\:\mathit{hil}}

\begin{inferences}
  \infer[\jrule{MP}]{\Gamma \vdash B \hil}{
    \Gamma \vdash A \to B \hil & \Gamma \vdash A \hil}
  \and
  \infer[\jrule{HYP}]{\Gamma, A \hil \vdash A \hil}{}
  \\
  \begin{array}{l}
    \Gamma \vdash A \to A \hil \\
    \Gamma \vdash A \to (B \to A) \hil \\
    \Gamma \vdash (A \to B \to C) \to (A \to B) \to (A \to C) \hil
  \end{array}
\end{inferences}

\begin{theorem}
  If $\Gamma \vdash A$, then $\hat{\Gamma} \vdash A \hil$.
\end{theorem}
\begin{proof}
  \begin{equation*}
    \infer[\rrule{\to}]{\Gamma \vdash A \to B}{
      \Gamma, A \vdash B}
  \end{equation*}
  We need a deduction theorem.

  \begin{equation*}
    \infer[\lrule{\to}]{\Gamma, A \to B \vdash C}{
      \Gamma, A \to B \vdash A & \Gamma, A \to B, B \vdash C}
  \end{equation*}
  We have $\Gamma, A \to B \vdash A \hil$ by induction.
  We also have $\Gamma, A \to B \vdash B \to C \hil$ by induction and the deduction theorem.
  Prove $\Gamma, A \to B \vdash B \hil$ by $\jrule{HYP}$ and $\jrule{MP}$.
  Conclude $\Gamma, A \to B \vdash C \hil$ by $\jrule{MP}$.

  \begin{equation*}
    \infer[\jrule{CUT}]{\Gamma \vdash C}{
      \Gamma \vdash A & \Gamma, A \vdash C}
  \end{equation*}
  Apply the inductive hypothesis and deduction theorem, then $\jrule{MP}$.
\end{proof}

\subsection{}

\NewDocumentCommand{\sem}{m}{\llbracket#1\rrbracket}

\begin{equation*}
  \begin{lgathered}
    \sem{x}\,\rho = \rho(x) \\
    \sem{\lambda x.M}\,\rho\,v = \sem{M}\,(\rho[x \mapsto v]) \\
    \sem{M\,N}\,\rho = \sem{M}\,\rho\,(\sem{N}\,\rho)
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    \sem{0}\,(\rho, v_0) = v_0 \qquad \sem{n+1}\,(\rho, v_0) = \sem{n}\,\rho \\
    \sem{\lambda x.M}\,\rho\,v_0 = \sem{M}\,(\rho, v_0) \\
    \sem{M\,N}\,\rho = \sem{M}\,\rho\,(\sem{N}\,\rho)
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    \sem{n} = \pi\,n \\
    \sem{\lambda x.M} = \Lambda\,\sem{M} \\
    \sem{M\,N} = S\,\sem{M}\,\sem{N}
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    \pi\,0\,(x,y) = y \qquad \pi\,(n+1)\,(x,y) = \pi\,n\,x \\
    \Lambda\,f\,x\,y = f\,(x,y) \\
    S\,x\,y\,z = x\,z\,(y\,z)
  \end{lgathered}
\end{equation*}


\begin{equation*}
  \begin{lgathered}
    \vdash \circ : (B \to C) \to (A \to B) \to (A \to C) \\
    \vdash \iota_1 : A \to A \lor B \\
    \vdash \iota_2 : B \to A \lor B \\
    f{:}A \to C, g{:}B \to C \vdash [f,g] : A \lor B \to C
  \end{lgathered}
\end{equation*}

\begin{equation*}
  \begin{lgathered}
    [f_1,f_2]\,(\iota_i\,x) = f_i\,x \\
    [f_1,f_2] \circ \iota_i = f_i
  \end{lgathered}
\end{equation*}


\begin{equation*}
  \begin{lgathered}
    \sem{\selectR{i_1}[P]} = S_1\,\sem{P} \\
    \sem{\caseL{i_1 => Q_1 | i_2 => Q_2}} = [\sem{Q_1}, \sem{Q_2}] \\
    \sem{\spawn{P}{Q}} = \sem{Q} \circ \sem{P}
  \end{lgathered}
\end{equation*}

\begin{equation*}
  [g_1, g_2](S_1\,f\,x) = g_1(f\,x) and S_1\,f\,x = \iota_1\,(f\,x)
\end{equation*}

\section{Natural deduction}

\begin{inferences}
  \infer[\jrule{HYP}]{A \vdash A}{}
  \and
  \infer-[\jrule{SUBST}]{A \vdash C}{
    A \vdash B & B \vdash C}
  \\
  \infer[{\plus}\text{\scshape i}]{A \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}}}{
    A \vdash B_{\kay} & \text{($\kay \in L$)}}
  \and
  \infer[{\plus}\text{\scshape e}]{A \vdash C}{
    A \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} &
    \multipremise{\ell \in L}{\!\!\!B_{\ell} \vdash C}}
  \\
  \infer[{\with}\text{\scshape i}]{A \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}}}{
    \multipremise{\ell \in L}{\!\!\!A \vdash B_{\ell}}}
  \and
  \infer[{\with}\text{\scshape e}]{A \vdash B_{\kay}}{
    A \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} & \text{($\kay \in L$)}}
\end{inferences}

\begin{theorem}
  If $A \vdash B$ in natural deduction, then $\slseq{A |- B}$ in the sequent calculus.
\end{theorem}
\begin{proof}
  \begin{equation*}
    \infer[{\with}\text{\scshape e}]{A \vdash B_{\kay}}{
      A \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} & \text{($\kay \in L$)}}  
    \rightsquigarrow
    \infer[\jrule{CUT}]{\slseq{A |- B_{\kay}}}{
      \slseq{A |- \with*[sub=_{\ell \in L}]{\ell:B_{\ell}}} &
      \infer[\lrule{\with}]{\slseq{\with*[sub=_{\ell \in L}]{\ell:B_{\ell}} |- B_{\kay}}}{
        \text{($\kay \in L$)}}}
  \end{equation*}
\end{proof}

\begin{theorem}
  If $A \vdash B$ in sequent calculus, then $\slseq{A |- B}$ in the natural deduction.
\end{theorem}
\begin{proof}
  \begin{gather*}
    \infer[\lrule{\with}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      A_{\kay} \vdash C & \text{($\kay \in L$)}}
    \\\rightsquigarrow\\
    \infer-[\jrule{SUBST}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      \infer[{\with}\text{\scshape e}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash A_{\kay}}{
        \infer[\jrule{HYP}]{\with*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash \with*[sub=_{\ell \in L}]{\ell:A_{\ell}}}{} &
        \text{($\kay \in L$)}} &
      A_{\kay} \vdash C}
  \end{gather*}

  \begin{gather*}
    \infer[\lrule{\plus}]{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      \multipremise{\ell \in L}{\!\!\!A_{\ell} \vdash C}}
    \\\rightsquigarrow\\
    \infer[{\plus}\text{\scshape e}]{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash C}{
      \infer[\jrule{HYP}]{\plus*[sub=_{\ell \in L}]{\ell:A_{\ell}} \vdash \plus*[sub=_{\ell \in L}]{\ell:A_{\ell}}}{} &
      \multipremise{\ell \in L}{\!\!\!A_{\ell} \vdash C}}
  \end{gather*}
\end{proof}


\begin{inferences}
  \infer[\jrule{HYP}]{A \dn \vdash A \dn}{}
  \and
  \infer-[\jrule{SUBST}]{A \dn \vdash C \up}{
    A \dn \vdash B \dn & B \dn \vdash C \up}
  \and
  \infer-[\jrule{SUBST}]{A \dn \vdash C \dn}{
    A \dn \vdash B \dn & B \dn \vdash C \dn}
  \\
  \infer[{\plus}\text{\scshape i}]{A \dn \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} \up}{
    A \dn \vdash B_{\kay} \up & \text{($\kay \in L$)}}
  \and
  \infer[{\plus}\text{\scshape e}]{A \dn \vdash C \up}{
    A \dn \vdash \plus*[sub=_{\ell \in L}]{\ell:B_{\ell}} \up &
    \multipremise{\ell \in L}{\!\!\!B_{\ell} \dn \vdash C \up}}
  \\
  \infer[{\with}\text{\scshape i}]{A \dn \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} \up}{
    \multipremise{\ell \in L}{\!\!\!A \dn \vdash B_{\ell} \up}}
  \and
  \infer[{\with}\text{\scshape e}]{A \dn \vdash B_{\kay} \dn}{
    A \dn \vdash \with*[sub=_{\ell \in L}]{\ell:B_{\ell}} \dn & \text{($\kay \in L$)}}
\end{inferences}

  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
