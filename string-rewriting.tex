\chapter{String rewriting for concurrent specifications}\label{ch:string-rewriting}

In this \lcnamecref{ch:string-rewriting}, we consider abstract rewriting as a framework for specifying the dynamics of concurrent systems.
This is not, of course, a new idea.
Multiset rewriting\autocites{Meseguer:TCS92}{Cervesato+Scedrov:IC09} has previously been put forward as a state-transformation model of concurrency, and has been used to describe security protocols\autocites{Cervesato+:CSFW99}{Durgin+:JCS04}, for example.
Unlike in multiset rewriting, we are particularly interested in concurrent systems whose components are arranged in a chain topology and have a monoidal structure.
Given that finite strings over an alphabet $\ialph$ form a free monoid, string rewriting, rather than multiset rewriting, is a good match for the structure we are interested in.

For a broad sketch of string rewriting, consider the finite strings over the alphabet $\Set{a,b}$, and let $\reduces$ be the least compatible binary relation over those strings that satisfies the axioms
\begin{equation}\label{eq:string-rewriting:ends-b-nondeterministic}
  \infer{a \wc b \reduces b}{}
  \qquad\text{and}\qquad
  \infer{b \reduces \emp}{}
  \:.
\end{equation}
This relation can be seen as a rewriting relation on strings.
For instance, because $a \wc b \wc b \reduces b \wc b$, we would say that $a \wc b \wc b$ may be rewritten to $b \wc b$.

More generally, under the rewriting axioms of \cref{eq:string-rewriting:ends-b-nondeterministic}, \change[ap]{a string $w$ ends with $b$ if, and only if, there exists a way to rewrite $w$ to the empty string}\footnote{\change[ap]{Though other rewritings that do not lead to the empty string may also exist; see below.}} -- that is, $w \reduces \dotsb \reduces \emp$.
For example, the string $abb$ ends with $b$, and $abb$ can indeed be rewritten to the empty string:
\begin{equation*}
  a \wc b \wc b
    \reduces b \wc b
    \reduces b
    \reduces \emp
  \,.
\end{equation*}
In this way, the rewriting axioms of \cref{eq:string-rewriting:ends-b-nondeterministic} constitute a specification of a system that identifies those strings over the alphabet $\Set{a,b}$ that end with $b$.

However, the usual operational semantics for string rewriting employs committed-choice nondeterminism, which
% this specification is nondeterministic
% and that that nondeterminism
can lead to stuck, or otherwise undesirable, states.
For example, although $abb$ certainly ends with $b$, the string $abb$ can be rewritten to $a$, a stuck state, if incorrect choices about which axioms to apply are made:
\begin{equation*}
  a \wc b \wc b \reduces a \wc b \reduces a \nreduces
  \,\!.
\end{equation*}
% even though $abb$ certainly ends with $b$.
No backtracking is performed to reconsider these choices.

Disjoint segments of a string may be rewritten independently.
For example, the substring $a \wc b$ can be rewritten to $b$, and the final $b$ of $a \wc b \wc b$ can be rewritten to the empty string.
Being independent, these rewritings can occur in either order, as shown in the adjacent \lcnamecref{fig:string-rewriting:independent1}.
\begin{marginfigure}[-4\baselineskip]
  \begin{equation*}
    \hphantom{a \wc b \wc {}}
    \begin{tikzcd}[ampersand replacement=\&, sep=small]
      \& b \wc b \drar[reduces]
      \\
      \mathllap{a \wc b \wc {}} b
        \urar[reduces]
        \drar[reduces]
      \&\& b
      \\
      \& \smash{a \wc b}\vphantom{a} \urar[reduces]
    \end{tikzcd}
  \end{equation*}
  \caption{The interleavings of two independent rewritings}\label{fig:string-rewriting:independent1}
\end{marginfigure}%
Concurrency arises when the various interleavings of independent rewritings are treated indistinguishably.

\newthought{The remainder of this \lcnamecref{ch:string-rewriting}} describes a string rewriting framework in more detail~\parencref{sec:string-rewriting:framework} and examines its properties, most importantly concurrent rewritings.
Then we present two extended examples of how string rewriting may be used to specify concurrent systems: \aclp*{NFA}~\parencref{sec:string-rewriting:nfa} and binary representations of natural numbers~\parencref{sec:string-rewriting:binary-counter}.
These will serve as recurring examples throughout the remainder of this document.

\section{A string rewriting framework}\label{sec:string-rewriting:framework}

In this \lcnamecref{sec:string-rewriting:framework}, we present a string rewriting framework and examine some of its basic properties.

\subsection{Symbols and strings}

String rewriting presupposes an alphabet, $\sralph$, of symbols $a$ from which finite strings are constructed.
This alphabet is usually, but need not be, finite.

Strings, $w$, are then finite lists of symbols: $w = a_1 \wc a_2 \dotsb a_n$.
Algebraically, strings form a free (noncommutative) monoid over symbols $a \in \sralph$ and may be described syntactically by the grammar
\begin{equation*}
  w \Coloneqq w_1 \wc w_2 \mid \emp \mid a
  \,,
\end{equation*}
where the monoid operation is string concatenation, denoted by $w_1 \wc w_2$, and the unit element is the empty string, denoted by $\emp$.%
% and $a$ is a symbol drawn from the alphabet $\ialph$.%
\footnote[][-2.25\baselineskip]{Strings are isomorphic to the finite words used by automata~\parencref{ch:automata}, but the two serve different conceptual roles in this document.}

As a monoid, strings are equivalent up to associativity and unit laws (see adjacent \lcnamecref{fig:string-rewriting:monoid-laws}).%
\begin{marginfigure}[0.5\baselineskip]
  \begin{gather*}
    (w_1 \wc w_2) \wc w_3 = w_1 \wc (w_2 \wc w_3) \\
    \emp \wc w = w = w \wc \emp
  \end{gather*}
  \caption{Monoid laws for strings}\label{fig:string-rewriting:monoid-laws}
\end{marginfigure}
We choose to keep this equivalence implicit, however, treating equivalent strings as syntactically indistinguishable.
As usual for a free monoid, the alternative grammar
  % \begin{equation*}
    $w \Coloneqq \emp \mid a \wc w$
  % \end{equation*}
can be used to   describe the same strings.


% The reason for the change of notation -- from $w$ and $\emp$ at the outset to $\octx$ and $(\emp$ here -- will become clear in the subsequent \lcnamecref{ch:ordered-rewriting}.

\subsection{A rewriting relation}

At the heart of string rewriting is a binary relation, $\reduces$, over strings.
When $w \reduces w'$, we say that $w$ can be rewritten to $w'$.
This relation is defined as the least compatible relation satisfying a collection of rewriting axioms, chosen on a per-application basis%
, such as the axioms
% For example, in the new notation, the axioms of \cref{eq:string-rewriting:ends-b-nondeterministic} are
\begin{equation*}% \label{eq:string-rewriting:ends-b-simpler}
  \infer{a \wc b \reduces b}{}
  \qquad\text{and}\qquad
  \infer{b \reduces \emp}{}
\end{equation*}
shown earlier.
More generally, an axiom is any pair of concrete, finite strings, $w \reduces w'$, although axioms of the form $\emp \reduces w'$ are expressly forbidden.
% Axioms $w \reduces w'$ may only rewrite a \emph{nonempty} concrete string $w$ into another, possibly empty concrete string $w'$.

To be more formal, these axioms are collected into a signature, $\srsig$, that indexes the rewriting relation:
\begin{equation*}
  \srsig \Coloneqq \srsige \mid \srsig, w \reduces w' \quad\text{($w \neq \emp$)}
\end{equation*}
The axioms of this signature may then be used via a $\jrule{$\reduces$AX}$ rule,
\begin{equation*}
  \infer[\mathrlap{\jrule{$\reduces$AX}}]{w \reduces_{\srsig} w'}{
    w \reduces w' \in \srsig}
  \mathrlap{\phantom{\jrule{$\reduces$AX}}\,.}
\end{equation*}
Aside from this rule, all of the other rules for the rewriting relation simply pass on the signature $\srsig$ untouched; for this reason, we nearly always elide the signature index on the rewriting relation, writing $\reduces$ instead of $\reduces_{\srsig}$.
As an example signature, the axioms of our running example can be packaged as
\begin{equation}\label{eq:string-rewriting:example-signature}
  \begin{lgathered}
    \sralph = \Set{ a, b } \\
    \srsig = (a \wc b \reduces b) \,, (b \reduces \emp)
  \,.
  \end{lgathered}
\end{equation}



In addition to the application-specific axioms contained within a signature, rewriting is always permitted within substrings,
so we adopt the rule
\begin{equation*}
  \infer[\jrule{$\reduces$C}]{w_1 \wc w_0 \wc w_2 \reduces w_1 \wc w'_0 \wc w_2}{
    w_0 \reduces w'_0}
\end{equation*}
to ensure that the rewriting relation is compatible with the monoidal structure of strings.

% With these compatibility rules, the axioms of \cref{eq:string-rewriting:ends-b-simpler} can be streamlined: they are derivable from the simpler rules
% \begin{equation}\label{eq:string-rewriting:ends-b-simplest}
%   \infer{a \oc b \reduces b}{}
%   \qquad\text{and}\qquad
%   \infer{b \reduces \octxe}{}
%   \:.
% \end{equation}

The $\reduces$ relation thus describes the rewritings that are possible in a single step: exactly one axiom, perhaps embellished by the compatibility rules.
\change[ic]{(We will also write $w \nreduces$ if there does \emph{not} exist a string $w'$ such that $w \reduces w'$.)}
In addition to the single-step rewritings, it will frequently be useful to describe the rewritings that are possible in some finite number of steps.
For this, we construct a multi-step rewriting relation, $\Reduces$, from the reflexive, transitive closure of $\reduces$.%
\footnote{Usually written as $\reduces^*$, we instead choose $\Reduces$ for the reflexive, transitive closure because of its similarity with standard process calculus notation for weak transitions, $\Reduces[\smash{\raisebox{-0.25ex}{$\scriptstyle\alpha$}}]$.
  Our reasons for this choice of notation will become clearer in subsequent \lcnamecrefs{ch:ordered-rewriting}.}

Consistent with its monoidal structure, there are two equivalent formulations of this reflexive, transitive closure: each rewriting sequence $w \Reduces w'$ can be viewed as either a list or tree of individual rewriting steps.
We prefer the list-based formulation,
\begin{inferences}
  \infer[\jrule{$\Reduces$R}]{w \Reduces w}{}
  \and\text{and}\and
  \infer[\jrule{$\Reduces$T}]{w \Reduces w''}{
    w \reduces w' & w' \Reduces w''}
  \,,
\end{inferences}
because it tends to streamline proofs by structural induction.
However, on the basis of the following \lcnamecref{lem:string-rewriting:trace-transitivity}, we allow ourselves to freely switch between the two formulations as needed.
\begin{lemma}[Transitivity of $\Reduces$]\label{lem:string-rewriting:trace-transitivity}
  If $w \Reduces w'$ and $w' \Reduces w''$, then $w \Reduces w''$.
\end{lemma}
\begin{proof}
  By structural induction over the first of the given rewriting sequences, $w \Reduces w'$.
\end{proof}

% This closure, denoted by $\Reduces$, is the least relation satisfying 
% \footnote{The $\jrule{$\Reduces$T}$ rule could be replaced by
%   \begin{equation*}
%     \infer{\octx \Reduces \octx'}{
%       \octx \reduces \octx'}
%     \qquad\text{and}\qquad
%     \infer{\octx \Reduces \octx''}{
%       \octx \Reduces \octx' & \octx' \Reduces \octx''}
%     \:,
%   \end{equation*}
%   but the $\jrule{$\Reduces$T}$ rule is slightly more convenient to work with in inductive proofs.}

A summary of string rewriting is shown in \cref{fig:string-rewriting:summary}.
\begin{figure}[tbp]
  \vspace*{\dimexpr-\abovedisplayskip-\abovecaptionskip\relax}
  \begin{syntax*}
    Strings &
      w & w_1 \wc w_2 \mid \emp \mid a
    \\
    Signatures &
      \srsig & \srsige \mid \srsig, w \reduces w'
      \mathrlap{\quad\text{($w \neq \emp$)}}
  \end{syntax*}
  \begin{gather*}
    (w_1 \wc w_2) \wc w_3 = w_1 \wc (w_2 \wc w_3) \\
    \emp \wc w = w = w \wc \emp
  \end{gather*}
  \begin{inferences}
    \infer[\jrule{$\reduces$AX}]{w \reduces_{\srsig} w'}{
      w \reduces w' \in \srsig}
    \and
    \infer[\jrule{$\reduces$C}]{w_1 \wc w_0 \wc w_2 \reduces w_1 \wc w'_0 \wc w_2}{
      w_0 \reduces w'_0}
    \\
    \infer[\jrule{$\Reduces$R}]{w \Reduces w}{}
    \and
    \infer[\jrule{$\Reduces$T}]{w \Reduces w''}{
      w \reduces w' & w' \Reduces w''}
  \end{inferences}
  \caption{A string rewriting framework}\label{fig:string-rewriting:summary}
  \forceversofloat
\end{figure}

\subsection{Properties of the string rewriting framework}\label{sec:string-rewriting:concurrency}

As an abstract rewriting system, the above string rewriting framework can be evaluated for several properties: confluence, termination, and, of particular interest to us, concurrency.

\paragraph*{Concurrency}
As an example multi-step rewriting sequence, observe that $a \wc b \wc b \Reduces \emp$, under the axioms of our running example~(\cref{eq:string-rewriting:example-signature}).
In fact, as shown in the adjacent \lcnamecref{fig:string-rewriting:abb}%
\begin{marginfigure}[2\baselineskip]
  \begin{equation*}
    \hphantom{a \wc b \wc {}}
    \begin{tikzcd}%[/tikz/baseline=]
      &
      b \wc b
        \drar[reduces]
      \\
      \mathllap{a \wc b \wc {}} b
        \urar[reduces]
        \drar[reduces]
        \arrow[Reduces]{rr}
      &&
      b \mathrlap{{} \reduces \emp}
      \\
      &
      \smash{a \wc b}\vphantom{a}
        \urar[reduces]
      % \rar[reduces]
      % &
      % a \mathrlap{{} \nreduces}
    \end{tikzcd}
    \hphantom{{} \reduces \emp}
  \end{equation*}
  \caption{An example of concurrent string rewriting}\label{fig:string-rewriting:abb}
\end{marginfigure}%
, multiple sequences witness this rewriting.
The initial $a \wc b$ can first be rewritten to $b$ and then the terminal $b$ can be rewritten to $\emp$ (upper half of \lcnamecref{fig:string-rewriting:abb}); or vice versa: the terminal $b$ can first be rewritten to $\emp$ and then the initial $a \wc b$ can be rewritten to $b$ (lower half of \lcnamecref{fig:string-rewriting:abb}).
In either case, the remaining $b$ (which is the leftmost of the original $b$s) can finally be rewritten to $\emp$.

Notice that these two sequences differ only in how non-overlapping, and therefore independent, rewritings of the string's two segments are interleaved.
Consequently, the two sequences can be -- and indeed should be -- considered essentially equivalent.
The details of how the individual, small steps are interleaved are irrelevant, so that -- conceptually at least -- only the big-step sequence from $a \wc b \wc b$ to $b$ (and ultimately $\emp$) remains (middle of \lcnamecref{fig:string-rewriting:abb}).

In contrast, a third rewriting sequence does not admit this reordering:
the leftmost $b$ is rewritten first to $\emp$ and then the resulting $a \wc b$ is rewritten to $b$ (and ultimately $\emp$).
This sequence's two rewriting steps are not independent because the $b$ that participates in the rewriting of $a \wc b$ is not adjacent to the $a$ until after the first rewriting step occurs.
This is captured in the adjacent \lcnamecref{fig:string-rewriting:abb-complete} by distinguishing the two $b$s with subscripts.
% This sequence's rewriting of $a \wc b$ into $b$ is not independent of the rewriting of the leftmost $b$ because the 
%
\begin{marginfigure}[-10\baselineskip]
  \begin{equation*}
    \begin{tikzcd}%[/tikz/baseline=]
      &
      b_1 \wc b_2
        \drar[reduces]
        \rar[reduces]
      &
      b_2
        \drar[reduces]
      &
      \\
      a \wc b_1 \wc b_2
        \urar[reduces]
        \drar[reduces]
        \arrow[Reduces]{rr}
        \arrow[reduces]{ddr}
      &&
      b_1
        \rar[reduces]
      &
      \emp
      \\
      &
      a \wc b_1
        \urar[reduces]
        \rar[reduces]
      &
      a \mathrlap{{} \nreduces}
      \\
      &
      a \wc b_2
        \urar[reduces]
        \arrow[reduces]{uuur}
    \end{tikzcd}
  \end{equation*}
  \caption{When multiple occurrences of $b$ are properly distinguished, a complete trace diagram can be given.}\label{fig:string-rewriting:abb-complete}
\end{marginfigure}%

More generally, this idea that the interleaving of independent actions is irrelevant is known as \vocab{concurrent equality}\autocite{Watkins+:CMU02}, and it forms the basis of concurrency.
With the partial commutativity endowed by concurrent equality, the free monoid formed by rewriting sequences is, more specifically, a trace monoid.
As such, we will frequently refer to rewriting sequences as \vocab{traces}.

\paragraph*{Non-confluence}
We may also evaluate string rewriting for confluence.
Confluence requires that all strings with a common ancestor be joinable, \ie, that $w'_1 \secudeR\Reduces w'_2$ implies $w'_1 \Reduces\secudeR w'_2$, for all strings $w'_1$ and $w'_2$.

String rewriting is an asymmetric, committed-choice relation, so some nondeterministic choices are irreversible.
For example, under the axioms of our running example (\cref{eq:string-rewriting:example-signature}), $a \wc b$ can be nondeterministically rewritten into either $a$ or $\emp$, as shown in \cref{fig:string-rewriting:abb-complete}%
% \begin{marginfigure}
%   \begin{equation*}
%     \begin{tikzcd}
%       & b \mathrlap{{} \reduces \emp}
%       \\
%       a \wc b
%         \urar[reduces]
%         \drar[reduces]
%       \\
%       & a \mathrlap{{} \nreduces}
%     \end{tikzcd}
%     \hphantom{{} \reduces \emp}
%   \end{equation*}
%   \caption{String rewriting is not confluent.}\label{fig:string-rewriting:ab-not-confluent}
% \end{marginfigure}%
.
However, neither $a$ nor $\emp$ can be rewritten, so confluence fails to hold for string rewriting in general.

\paragraph*{Non-termination}
In our running example, rewriting always terminates: each possible rewriting step removes exactly one symbol, and each string contains only finitely many symbols.

In general, string rewriting does not terminate even though strings are finite.
For a simple example, consider rewriting of strings over the alphabet $\Set{a,b}$ with axioms
$a \reduces b$ and $b \reduces a$.
Every finite trace from a nonempty string can always be extended by applying one of these axioms, so string rewriting in this example never terminates.

\section{Example: \Aclp*{NFA}}\label{sec:string-rewriting:nfa}

As an extended example of string rewriting, we will specify how \iac{NFA} processes its input.
Beginning with this specification, \acp{NFA} will serve as a recurring example throughout the remainder of this document.
 
Given \iac{NFA} $\aut{A} = (Q, \nfapow, F)$ over an input alphabet $\ialph$, the idea is to introduce a string rewriting axiom for each transition that the \ac{NFA} can make:
\begin{equation*}
  \infer{a \wc q \reduces q'_a}{}
  \enspace\text{for each transition $q \nfareduces[a] q'_a$.}
\end{equation*}
In addition, the \ac{NFA}'s acceptance criteria is captured by introducing a distinguished symbol $\eow$ to act as an end-of-word marker, along with axioms
\begin{equation*}
  \infer{\eow \wc q \reduces F(q)}{}
  \enspace\text{for each state $q$, where }
  F(q) = \begin{cases*}
           \symacc & if $q \in F$ \\
           \symrej & if $q \notin F$\,.
         \end{cases*}
\end{equation*}
These axioms imply that rewriting occurs over the finite strings from $\Set{\eow} \times \finwds{\ialph} \times Q \union \Set{ \symacc , \symrej }$.
Expressed as a string rewriting signature, the \ac{NFA} $\aut{A}$ is
\begin{equation*}
  \srsig = \Set{ a \wc q \reduces q'_a \given q \nfareduces[a] q'_a }
             \union \Set{ \eow \wc q \reduces F(q) \given q \in Q }
  \,,
\end{equation*}
where $F(q)$ is defined as above.

For a concrete instance of this encoding, recall from \cref{ch:automata} the \ac{NFA} (repeated in the adjacent \lcnamecref{fig:string-rewriting:nfa-example-ends-b})%
%
\begin{marginfigure}[-8.1\baselineskip]
  \begin{equation*}
    \mathllap{\aut{A}_1 = {}}
    \begin{tikzpicture}[baseline=(q_0.base)]
        \graph [automaton] {
          q_0
           -> [loop above, "a,b"]
          q_0
           -> ["b"]
          q_1 [accepting]
           -> ["a,b"]
          q_2
           -> [loop above, "a,b"]
          q_2;
        };
      \end{tikzpicture}
  \end{equation*}
  \caption{\Iac*{NFA} that accepts, from state $q_0$, exactly those words that end with $b$. (Repeated from \cref{fig:nfa-example-ends-b}.)}\label{fig:string-rewriting:nfa-example-ends-b}
\end{marginfigure}
%
that accepts exactly those words, over the alphabet $\ialph = \set{a,b}$, that end with $b$; that \ac{NFA} is specified by the following string rewriting axioms:
\begin{equation*}
  \srsig_{\aut{A}_1}\!
    = \begin{array}[t]{@{}l@{\,,{}}c@{\,,{}}l@{}}
        (a \wc q_0 \reduces q_0) & (b \wc q_0 \reduces q_0) \,, (b \wc q_0 \reduces q_1) & (\eow \wc q_0 \reduces \symrej) \,, \\
        (a \wc q_1 \reduces q_2) & (b \wc q_1 \reduces q_2) & (\eow \wc q_1 \reduces \symacc) \,, \\
        (a \wc q_2 \reduces q_2) & (b \wc q_2 \reduces q_2) & (\eow \wc q_2 \reduces \symrej) \,.
      \end{array}
\end{equation*}
Indeed, just as the \ac{NFA} $\aut{A}_1$ accepts the input word $abb$, its rewriting specification admits a trace
\begin{equation*}
  \eow \wc b \wc b \wc a \wc q_0
    \reduces \eow \wc b \wc b \wc q_0
    \reduces \eow \wc b \wc q_0
    \reduces \eow \wc q_1
    \reduces \symacc
  \,.
\end{equation*}

More generally, this string rewriting specification of \acp{NFA} adequately describes their operational semantics, in the sense that it simulates all \ac{NFA} transitions.
Given the reversal\footnote[][2.5\baselineskip]{\change[ic]{At this point in the narrative, it would probably make more sense to specify \acp{NFA} without reversing the input word, writing the state $q_i$ at the string's left end.  But we choose this specification instead because it will align more conveniently with the most natural process chain implementation of \acp{DFA} and transducers~\parencref{sec:process-chains:transducer}.}} (anti-)\-homo\-morph\-ism for finite words defined in the adjacent \lcnamecref{fig:string-rewriting:reversal}%
\begin{marginfigure}[-28
\baselineskip]
  \begin{align*}
    \rev*{w_1 \wc w_2} &= \rev{w_2} \oc \rev{w_1} \\
    \rev{\emp} &= \emp \\
    \rev{a} &= a
  \end{align*}
  \caption{An (anti-)\-homo\-morph\-ism for reversal of finite words}\label{fig:string-rewriting:reversal}
\end{marginfigure}%
, we can prove the following adequacy result.
\begin{restatable}[
  name=Adequacy of \ac*{NFA} specification,
  label=thm:nfa-adequacy-string-rewriting
]{theorem}{nfaadequacystringrewriting}
  Let $\aut{A} = (Q, \nfapow, F)$ be \iac{NFA} over the input alphabet $\ialph$.
  \begin{itemize}[nosep]
  \item
    $q \nfareduces[a] q'_a$ if, and only if, $a \oc q \reduces q'_a$, for all input symbols $a \in \ialph$.
  \item
    $q \in F$ if, and only if, $\eow \oc q \reduces \symacc$.%, where the atom $\emp$ functions as an end-of-word marker.
  \item
    $q \nfareduces[w] q'$ if, and only if, $\rev{w} \oc q \Reduces q'$, for all finite words $w \in \finwds{\ialph}$.
  \end{itemize}  
\end{restatable}
\begin{proof}
  The first two parts follow immediately from the \ac{NFA}'s string rewriting specification; the third part follows by induction over the structure of the input word $w$.
\end{proof}

This adequacy \lcnamecref{thm:nfa-adequacy-string-rewriting} is relatively straightforward to state and prove because string rewriting is a good match for labeled transition systems, like the one that defines \iac{NFA}'s operational semantics.
On the other hand, when a system is not so clearly based on a labeled transition system, stating and proving the adequacy of its string rewriting specification becomes a bit more involved.
This is the case for the next example, binary representations of natural numbers.

\section{Example: Binary representations of natural numbers}\label{sec:string-rewriting:binary-counter}

For a second recurring example, we will use
binary representations of natural numbers equipped with increment and decrement operations. % , or \vocab{binary counters}.
% , will serve as a second recurring example throughout the remainder of this document.
Here we present a string rewriting specification of these \emph{binary counters}.
% further example of string rewriting, consider a specification of binary counters: binary representations of natural numbers equipped with increment and decrement operations.

\subsection{Binary representations}

In this setting, we represent a natural number in binary by a string that consists of a big-endian sequence of symbols $b_0$ and $b_1$, prefixed by the symbol $e$; leading $b_0$s are permitted.
For example, both $w = e \oc b_1$ and $w' = e \oc b_0 \oc b_1$ are valid binary representations of the natural number $1$.

To be more precise, we inductively define a relation, $\aval{}{}$, that assigns to each binary representation a unique natural number denotation.
If $\aval{w}{n}$, we say that $w$ denotes, or represents, natural number $n$ in binary.
\begin{inferences}
  \infer[\jrule{$e$-V}]{\aval{e}{0}}{}
  \and
  \infer[\jrule{$b_0$-V}]{\aval{w \oc b_0}{2n}}{
    \aval{w}{n}}
  \and
  \infer[\jrule{$b_1$-V}]{\aval{w \oc b_1}{2n+1}}{
    \aval{w}{n}}
\end{inferences}
Besides providing a denotational semantics of binary numbers, the $\aval{}{}$ relation also serves to implicitly characterize the well-formed binary numbers as those strings $w$ that form the relation's domain of definition.%
\footnote{Alternatively, the well-formed binary numbers could be described more explicitly by the grammar
\begin{equation*}
  w \Coloneqq e \mid w \oc b_0 \mid w \oc b_1
  \,,
\end{equation*}
and then their denotations could be expressed in a more functional manner:
\begin{equation*}
  \begin{lgathered}
    \deno[V]{e} = 0 \\
    \deno[V]{w \oc b_0} = 2 \deno[V]{w} \\
    \deno[V]{w \oc b_1} = 2 \deno[V]{w} + 1
    \,.
  \end{lgathered}
\end{equation*}
We prefer the purely relational formulation, however.%
}


The adequacy of the $\aval{}{}$ relation is proved as the following \lcnamecref{thm:ordered-rewriting:binary-adequacy}.
%
\begin{theorem}[Adequacy of binary representations]\label{thm:ordered-rewriting:binary-adequacy}
  Binary representations and their $\aval{}{}$ relation are:
  \begin{thmdescription}
  \item[\emph{Functional}]
    For each binary number $w$, there exists a unique natural number $n$ such that $\aval{w}{n}$.
  \item[\emph{Surjective}]
    For each natural number $n$, there exists a binary number $w$ such that $\aval{w}{n}$.
  \item[\emph{Latent}]
    If $\aval{w}{n}$, then $w \nreduces$.
  \end{thmdescription}
\end{theorem}
\begin{proof}
  The three claims may be proved by induction over the structure of $w$, and by induction on $n$, respectively.
\end{proof}

Notice that the above $\jrule{$e$-V}$ and $\jrule{$b_0$-V}$ rules overlap when the denotation is $0$, giving rise to the leading $b_0$s that make the $\aval{}{}$ relation non-injective:
for example, both $\aval{e \oc b_1}{1}$ and $\aval{e \oc b_0 \oc b_1}{1}$ hold.
However, if the $\jrule{$b_0$-V}$ is restricted to \emph{nonzero} even numbers, then each natural number has a unique, canonical representation that is free of leading $b_0$s.%
\footnote[][-3\baselineskip]{%
  A restriction of the $b_0$ rule to nonzero even numbers is:
  \begin{equation*}
    \infer{\aval{w \oc b_0}{2n}}{
      \aval{w}{n} & \text{($n > 0$)}}
  \,.
  \end{equation*}
  The leading-$b_0$-free representations could alternatively be seen as the canonical representatives of the equivalence classes induced by the relation among binary numbers that have the same denotation: $w \equiv w'$ if $\aval{w}{n}$ and $\aval{w'}{n}$ for some $n$.}


\subsection{An increment operation}

To use string rewriting to describe an increment operation on binary representations, we introduce a new symbol, $i$, that will serve as an increment instruction.

Given a binary number $w$ that represents $n$, we may append $i$ to form an active%
\footnote{The \enquote*{active}, \enquote*{latent}, and \enquote*{passive} terminology is borrowed from \textcite{Pfenning+Simmons:LICS09}.
  Active strings are immediately rewritable, but latent strings are rewritable only when combined with other, passive strings.
  The blurry line between latent and passive strings is exploited in \cref{ch:formula-as-process} when we discuss choreographies.}%
, computational string, $w \oc i$.
For $i$ to adequately represent the increment operation, the string $w \oc i$ must meet two conditions, captured by the following global desiderata:
% \begin{theorem}\label{thm:increment-structural-adequacy}
%   Let $\octx$ be a binary representation of $n$.
%   Then:
  \begin{itemize}% [nosep]
  \item
    % \emph{some} computation from $\octx \oc i$ results in a binary representation of $n+1$ -- that is, $\octx \oc i \Reduces\aval{}{n+1}$; and
    $w \oc i \Reduces\aval{}{n+1}$ -- that is, \emph{some} rewriting sequence results in a binary representation of $n+1$; and
  \item
    % \emph{any} computation from $\octx \oc i$ results in a binary representation of $n+1$ -- that is, $\octx \oc i \Reduces\aval{}{n'}$ only if $n' = n+1$.%
    $w \oc i \Reduces w'$ implies $w' \Reduces\aval{}{n+1}$ -- that is, \emph{any} rewriting sequence from $w \oc i$ can result in a binary representation of $n+1$.
  \end{itemize}
% \end{theorem}
% \noindent
For example, because $e \oc b_1$ denotes $1$, a computation $e \oc b_1 \oc i \Reduces\aval{}{2}$ must exist; moreover, every computation $e \oc b_1 \oc i \Reduces\aval{}{n'}$ must satisfy $n' = 2$.

\newthought{To achieve these} global desiderata, we introduce three string rewriting axioms that describe how the symbols $e$, $b_0$, and $b_1$ may be rewritten when they encounter $i$, the increment instruction:
\begin{inferences}
  \infer{e \oc i \reduces e \oc b_1}{}
  \and
  \infer{b_0 \oc i \reduces b_1}{}
  \and\text{and}\and
  \infer{b_1 \oc i \reduces i \oc b_0}{}
  \,.
\end{inferences}
These three axioms can be read as follows:
\begin{itemize}
\item
  To increment $e$, replace $e$ (and $i$) with $e \oc b_1$.
  % append $b_1$ as a new most\fixnote{or least?} significant bit, resulting in $e \oc b_1$.
\item
  To increment a binary number ending in $b_0$, flip that bit to $b_1$.
\item
  To increment a binary number ending in $b_1$, flip that bit to $b_0$ and carry the increment over to the more significant bits.
\end{itemize}
Comfortingly, $1+1 = 2$: a trace $e \oc b_1 \oc i \reduces e \oc i \oc b_0 \reduces e \oc b_1 \oc b_0$ indeed exists.

Owing to the notion of concurrent equality that string rewriting admits, increments may even be performed concurrently.
For example, there are two rewriting sequences that witness $e \oc b_1 \oc i \oc i \Reduces e \oc b_1 \oc b_1$:
\begin{equation*}
  \hphantom{e \oc b_1 \oc i \oc i \reduces e \oc i \oc b_0 \oc {}}%
  \begin{tikzcd}[
    cells={inner xsep=0.65ex,
           inner ysep=0.4ex},
    row sep=0.2em,
    column sep=scriptsize
  ]
    &[-0.2em]
    e \oc b_1 \oc b_0 \oc i
      \drar[reduces, start anchor=base east]%,
                    % end anchor=north west]
    &[-0.2em]
    \\
    \mathllap{e \oc b_1 \oc i \oc i \reduces e \oc i \oc b_0 \oc {}} i
      \urar[reduces,% start anchor=north east,
                     end anchor=base west]
      \ar[Reduces, gray, dashed, shorten <= .8ex, shorten >= .8ex]{rr}
      \drar[reduces,% start anchor=base east,
                     end anchor=west]
    &&
    e \mathrlap{{} \oc b_1 \oc b_1}
    \\
    &
    e \oc i \oc b_1
      \urar[reduces, start anchor=east]%,
                    % end anchor=base west]
    &
  \end{tikzcd}%
  \hphantom{{} \oc b_1 \oc b_1}
\end{equation*}
In other words, once the left most increment is carried past the least significant bit, the two increments can be interleaved, with no observable difference in the outcome.


\newthought{These increment axioms} introduce strings that occur as intermediate computational states within traces, such as $e \oc i \oc b_0 \oc i$ and $e \oc i \oc b_1$ in the above diagram.
To characterize the valid intermediate strings, we define a binary relation, $\ainc{}{}$, that assigns a natural number denotation to each such intermediate string, not only to the terminal values, as $\aval{}{}$ did.%
\footnote{Like the $\aval{}{}$ relation does for values, the $\ainc{}{}$ relation also serves to implicitly characterize the valid intermediate states as those contexts that form the relation's domain of definition.
As with values, the valid intermediate states could also be enumerated more explicitly and syntactically with a grammar and denotation function:
\begin{equation*}
  w \Coloneqq e \mid w \oc b_0 \mid w \oc b_1 \mid w \oc i
\end{equation*}
\begin{equation*}
  \begin{lgathered}
    \deno[I]{e} = 0 \\
    \deno[I]{w \oc b_0} = 2 \deno[I]{w} \\
    \deno[I]{w \oc b_1} = 2 \deno[I]{w} + 1 \\
    \deno[I]{w \oc i} = \deno[I]{w} + 1
  \end{lgathered}
\end{equation*}
However, we once again prefer the purely relational form.}%
%
\begin{inferences}
  \infer[\jrule{$e$-I}]{\ainc{e}{0}}{}
  \and
  \infer[\jrule{$b_0$-I}]{\ainc{w \oc b_0}{2n}}{
    \ainc{w}{n}}
  \and
  \infer[\jrule{$b_1$-I}]{\ainc{w \oc b_1}{2n+1}}{
    \ainc{w}{n}}
  \and
  \infer[\jrule{$i$-I}]{\ainc{w \oc i}{n+1}}{
    \ainc{w}{n}}
\end{inferences}
Binary values should themselves be valid, terminal computational states, so the first three rules are carried over from the $\aval{}{}$ relation.
The $\jrule{$i$-I}$ rule allows multiple increment instructions to be interspersed throughout the state.

With this $\ainc{}{}$ relation in hand, we can now prove a stronger, small-step adequacy theorem.
This small-step \lcnamecref{thm:string-rewriting:inc-small-step-adequacy} then implies the big-step desiderata from above.
%
\begin{restatable}[
  name=Small-step adequacy of increments,
  label=thm:string-rewriting:inc-small-step-adequacy
]{theorem}{thmincsmallstepadequacy}
  \leavevmode
  \begin{thinthmdescription}
  \item[Value soundness]
    If $\aval{w}{n}$, then $\ainc{w}{n}$ and $w \nreduces$.
  \item[Preservation]
    If $\ainc{w}{n}$ and $w \reduces w'$, then $\ainc{w'}{n}$.
  \item[Progress]
    If $\ainc{w}{n}$, then either
    \begin{itemize*}[
      % mode=unboxed,
      label=, afterlabel=,
      before=\unskip:\space,
      itemjoin=;\space, itemjoin*=; or\space%
    ]
    \item $w \reduces w'$ for some $w'$
    \item $\aval{w}{n}$% \fixnote{Compare with \enquote{If $\ainc{\octx}{n}$, then $\aval{\octx}{n}$ if, and only if, $\octx \nreduces$.}}
    \end{itemize*}.
  \item[Termination]
    If $\ainc{w}{n}$, then every rewriting sequence from $w$ is finite.
  \end{thinthmdescription}
\end{restatable}
%
\begin{proof}
  Each part is proved separately.
  \begin{description}[
    parsep=0pt, listparindent=\parindent,
    labelsep=0.35em
  ]
  \item[Value soundness]
    can be proved by structural induction on the derivation of $\aval{w}{n}$.
  \item[Preservation and progress]
    can likewise be proved by structural induction on the derivation of $\ainc{w}{n}$.
  \item[Termination]
    can be proved using an explicit termination measure, $\card[i]{}$, that is strictly decreasing across each rewriting, $w \reduces w'$.
    Specifically, we use a measure (see the adjacent \lcnamecref{fig:string-rewriting:binary-counter:measure}),
    % For valid states $\octx$, we define a measure $\card{\octx}$ that is strictly decreasing across each rewriting $\octx \reduces \octx'$ (see the adjacent \lcnamecref{fig:ordered-rewriting:binary-counter:measure}).
    \begin{marginfigure}
      \begin{equation*}
        \begin{lgathered}
          \card[i]{e} = 0 \\
          \card[i]{w \oc b_0} = \card[i]{w} \\
          \card[i]{w \oc b_1} = \card[i]{w} + 1 \\
          \card[i]{w \oc i} = \card[i]{w} + 2
          % e + i > e + b1  =>  e >= 0
          % b0 + i > b1
          % b1 + i > i + b0 > b1  =>  i > 1
        \end{lgathered}
      \end{equation*}
      \caption{A termination measure, adapted from the standard amortized work analysis of increment for binary counters}\label{fig:string-rewriting:binary-counter:measure}
    \end{marginfigure}%
    adapted from the standard amortized constant work analysis of increment for binary counters\autocite{Cormen+:MIT09}.
    The measure $\card[i]{}$ is such that $w \reduces w'$ implies $\card[i]{w} > \card[i]{w'}$;
    % That is, if $\octx$ is a valid state and $\octx \reduces \octx'$, then $\card{\octx} > \card{\octx'}$.
    because the measure is always nonnegative, only finitely many such rewritings can occur.

    As an example case, consider the intermediate state $w \oc b_1 \oc i$ and its rewriting $w \oc b_1 \oc i \reduces w \oc i \oc b_0$.
    Indeed, $\card[i]{w \oc b_1 \oc i} = \card[i]{w} + 3 > \card[i]{w} + 2 = \card[i]{w \oc i \oc b_0}$.
  \qedhere
  \end{description}
\end{proof}

\begin{corollary}[Big-step adequacy of increments]
  \leavevmode
  \begin{thinthmdescription}
  \item[Evaluation]
    If $\ainc{w}{n}$, then $w \Reduces\aval{}{n}$.
    In particular, if $\aval{w}{n}$, then $w \oc i \Reduces\aval{}{n+1}$.
  \item[Preservation]
    If $\ainc{w}{n}$ and $w \Reduces w'$, then $\ainc{w'}{n}$.
    In particular, if $\aval{w}{n}$ and $w \oc i \Reduces w'$, then $w' \Reduces\aval{}{n+1}$.
  \end{thinthmdescription}
\end{corollary}
\begin{proof}
  The two parts are proved separately.
  \begin{description}[labelsep=0.35em]
  \item[Evaluation] can be proved by repeatedly appealing to the progress and preservation results~\parencref{thm:string-rewriting:inc-small-step-adequacy}.
    By the accompanying termination result, a binary value must eventually be reached.
  \item[Preservation] can be proved by structural induction on the given trace.
  %
  \qedhere
  \end{description}
\end{proof}


% \clearpage
\subsection{A decrement operation}

Binary counters may also be equipped with a decrement operation.
Instead of examining decrements \emph{per se}, we will describe a very closely related operation: the normalization of binary representations to what might be called \vocab{head-unary form}.
(We will frequently abuse terminology, using \enquote*{head-unary normalization} and \enquote*{decrement operation} interchangeably.)
% A string $w$ will be said to be in head-unary form if it has one of two forms: $w = z$; or $w = w' \oc s$, for some binary number $w'$.

\change[ic]{The possible head-unary forms are $z$ and $w' \oc s$, where $w'$ is a binary number.
The symbols $z$ and $s$ were chosen to suggest the zero and successor constructors for unary representations of natural numbers.
In this way, $z$ is the unique head-unary form of every binary number $w$ that denotes $0$, and $w' \oc s$ is a head-unary form of binary number $w$, if $w$ denotes $n>0$ and $w'$ denotes $n-1$.
For example, $e \oc b_0$ has head-unary form $z$, and $e \oc b_1 \oc b_0$ has $e \oc b_0 \oc b_1 \oc s$ as a head-unary form\footnote{Leading $b_0$s could also be added or removed to this head-unary form}.}

Just as appending the symbol $i$ to a counter $w$ initiates an increment, appending a symbol $d$ will cause the counter to begin normalizing to head-unary form.
In other words, $w \oc d$ will rewrite to either $z$ (representing the head-unary form of the number $0$) or $w' \oc s$ (representing a head-unary normal form of the number $n>0$, where $w'$ denotes $n-1$).

For $d$ to adequately represent this operation, the string $w \oc d$ must satisfy the following global desiderata when $\adec{w}{n}$:
% The following \lcnamecref{thm:decrement-adequacy} serves as a specification of head-unary normalization, relating a value's head-unary form to its denotation.
%
% \begin{theorem}[Structural adequacy of decrements]
%   If $\aval{\octx}{n}$, then:
  \begin{itemize}% [nosep]
  \item $w \oc d \Reduces z$ if, and only if, $n=0$;
  \item $w \oc d \Reduces w' \oc s$ for some $w'$ such that $\aval{w'}{n-1}$, if $n > 0$; and
  \item $w \oc d \Reduces w' \oc s$ only if $n > 0$ and $\aval{w'}{n-1}$.
  \end{itemize}
% \end{theorem}
%
% \noindent
\change[ic]{Notice that these last two desiderata function as converses.}
For example, because $e \oc b_1$ denotes $1$, there must exist a trace $e \oc b_1 \oc d \Reduces w' \oc s$ for some $\aval{w'}{0}$.
\change[ic]{Conversely, because $e$ denotes $0$, there must \emph{not} exist a trace $e \oc d \Reduces w' \oc s$ for any $w'$.}

\newthought{To achieve these} global desiderata, we introduce three additional axioms that describe how the symbols $e$, $b_0$, and $b_1$ may be rewritten when they encounter $d$, the decrement instruction;
also, an intermediate symbol $b'_0$ and two more axioms are introduced:
\begin{inferences}
  \infer{e \oc d \reduces z}{}
  \and
  \infer{b_1 \oc d \reduces b_0 \oc s}{}
  \and
  \infer{b_0 \oc d \reduces d \oc b'_0}{}
  \\
  \infer{z \oc b'_0 \reduces z}{}
  \and\text{and}\and
  \infer{s \oc b'_0 \reduces b_1 \oc s}{}
  \,.
\end{inferences}
These five axioms can be read as follows:
\begin{itemize}
\item
  Because $e$ denotes $0$, its head-unary form is simply $z$.
\item
  Because $w \oc b_1$ denotes $2n+1$ if $w$ denotes $n$, its head-unary form, $w \oc b_0 \oc s$, can be constructed by flipping the least significant bit to $b_0$ and appending $s$.
\item
  Because $w \oc b_0$ denotes $2n$ if $w$ denotes $n$, its head-unary form can be constructed by recursively putting the more significant bits, $w$, into head-unary form and appending $b'_0$ to process that result.
  \begin{itemize}
  \item
    If $w$ has head-unary form $z$ and therefore denotes $0$, then $w \oc b_0$ also denotes $0$ and has head-unary form $z$.
  \item
    Otherwise, if $w$ has head-unary form $w' \oc s$ and thus denotes $n > 0$, then $w \oc b_0$ denotes $2n > 0$ and has head-unary form $w' \oc b_1 \oc s$, which can be constructed by replacing $s$ with $b_1 \oc s$.
  \end{itemize}
\end{itemize}
%
Comfortingly, $(1+1)-1 = 1$: the head-unary form of $e \oc b_1 \oc i$ is $e \oc b_0 \oc b_1 \oc s$:
\begin{equation*}
  \hphantom{e \oc b_1 \oc i \oc d \reduces e \oc i \oc b_0 \oc {}}%
  \begin{tikzcd}[
    cells={inner xsep=0.65ex,
           inner ysep=0.4ex},
    row sep=0em,
    column sep=scriptsize
  ]
    &[-0.2em]
    e \oc b_1 \oc b_0 \oc d
      \drar[reduces, start anchor=base east]%,
                    % end anchor=north west]
    &[-0.2em]
    \\
    \mathllap{e \oc b_1 \oc i \oc d \reduces e \oc i \oc b_0 \oc {}} d
      \urar[reduces,% start anchor=north east,
                     end anchor=base west]
      \ar[Reduces, gray, dashed, shorten <=.8ex, shorten >=.8ex]{rr}
      \drar[reduces,% start anchor=base east,
                     end anchor=west]
    &&
    e \mathrlap{{} \oc b_1 \oc d \oc b'_0
      \reduces e \oc b_0 \oc s \oc b'_0
      \reduces e \oc b_0 \oc b_1 \oc s}
    \\
    &
    e \oc i \oc d \oc b'_0
      \urar[reduces, start anchor=east]%,
                     % end anchor=base west]
    &
  \end{tikzcd}
 \hphantom{{} \oc b_1 \oc d \oc b'_0
      \reduces e \oc b_0 \oc s \oc b'_0
      \reduces e \oc b_0 \oc b_1 \oc s}
  .
\end{equation*}
Note the concurrency that derives from the independence of the increment and decrement after the initial step of rewriting.


\newthought{These decrement axioms} introduce more strings that may occur as intermediate computational states.
As before, we define a new binary relation, $\adec{}{}$, that assigns a natural number denotation to each string that may appear as an intermediate state during a decrement.
\begin{inferences}
  \infer[\jrule{$d$-D}]{\adec{w \oc d}{n}}{
    \ainc{w}{n}}
  \and
  \infer[\jrule{$b'_0$-D}]{\adec{w \oc b'_0}{2n}}{
    \adec{w}{n}}
  \and
  \infer[\jrule{$z$-D}]{\adec{z}{0}}{}
  \and
  \infer[\jrule{$s$-D}]{\adec{w \oc s}{n+1}}{
    \ainc{w}{n}}
\end{inferences}
At first glance, the $\jrule{$d$-D}$ rule may look a bit odd:
Why is the denotation unchanged by a decrement, $w \oc d$?
Because the operation is more accurately characterized as head-unary normalization, it makes sense that the denotation remains unchanged.
The operation described by $d$ does not change the binary counter's value -- it only expresses that same value in a different form.%
\footnote[][-8\baselineskip]{Once again, the valid intermediate states could also be enumerated more explicitly and syntactically with a grammar and denotation function:%
\begin{align*}
  w &\Coloneqq e \mid w \oc b_0 \mid w \oc b_1 \mid w \oc i \\
  w^h &\Coloneqq w \oc d \mid w^h \oc b'_0 \mid z \mid w \oc s
\end{align*}
\begin{equation*}
  \begin{lgathered}
    \deno[D]{w \oc d} = \deno[I]{w} \\
    \deno[D]{w^h \oc b'_0} = 2 \deno[D]{w^h} \\
    \deno[D]{z} = 0 \\
    \deno[D]{w \oc s} = \deno[I]{w} + 1
  \end{lgathered}
\end{equation*}}%

Also, notice that the premises of the $\jrule{$d$-D}$ and $\jrule{$s$-D}$ rules use the increment-only denotation relation, $\ainc{}{}$, not the decrement relation, $\adec{}{}$.
These choices ensure that each counter has at most one $d$ and may not have any $i$ or $s$ symbols to the right of that $d$.
But the premise of the $\jrule{$b'_0$-D}$ does use the $\adec{}{}$ relation, so $d$ may have $b'_0$ symbols to its right.


% e + i > e + b1
% e + d > z
% b0 + i > b1
% b0 + d > d + b0'
% b1 + i > i + b0
% b1 + d > b0 + s
% z + b0' > z
% s + b0' > b1 + s

% |O d| = |O| + 1
% |O b0'| = |O| + 1
% |z| = 0
% |O s| = 0
% |e| = 0
% |O b0| = |O| + 2
% |O b1| = |O| + 3
% |O i| = |O| + 4

% |O d|d = |O|i + 1
% |O b0'|d = |O|d + 1
% |z|d = 0
% |O s|d = 0
%
% |O|i = 2L(O) + |O|

% |O d|d = |O| + 3L(O)
% |O b0'|d = |O|d + 2
% |z|d = 0
% |O s|d = |O|

% 3 > 0
% |O| + 3L(O) + 3 > |O| + 3L(O) + 2
% |O| + 1 + 3L(O) + 3 > |O|
% 2 > 0
% |O| + 2 > |O| + 1


% 4 > 3
% 1 > 0
% 6 > 3
% 3 > 2
% 7 > 6
% 5 > 0
% 1 > 0
% 1 > 0

% e + d > z
% b0 + d > d + b0'
% b1 + d > s
% b0' > 0
% b0' > 0

% b0' = 1

With this $\adec{}{}$ relation in hand, we can now prove a small-step adequacy \lcnamecref{thm:string-rewriting:dec-small-step-adequacy}.
This small-step \lcnamecref{thm:string-rewriting:dec-small-step-adequacy} then implies the big-step desiderata from above.
%
\begin{restatable}[
  name=Small-step adequacy of decrements,
  label=thm:string-rewriting:dec-small-step-adequacy
]{theorem}{thmadequacysmalldecstring}
  \leavevmode
  \begin{thinthmdescription}[leftmargin=0em]
  \item[Preservation]
    If $\adec{w}{n}$ and $w \reduces w'$, then $\adec{w'}{n}$.
  \item[Progress]
    If $\adec{w}{n}$, then either:
    \begin{itemize}[nosep]
    \item $w \reduces w'$, for some $w'$;
    \item $n = 0$ and $w = z$; or
    \item $n > 0$ and $w = w' \oc s$, for some $w'$ such that $\ainc{w'}{n-1}$.
    \end{itemize}
  \item[Termination]
    If $\adec{w}{n}$, then every rewriting sequence from $w$ is finite.
  \end{thinthmdescription}
\end{restatable}
\begin{proof}
  Each part is proved separately.
  \begin{description}[
    parsep=0pt, listparindent=\parindent,
    labelsep=0.35em
  ]
  \item[Preservation and progress]
    are proved, as before, by structural induction on the given derivation of $\adec{w}{n}$.
  \item[Termination] is proved by exhibiting a measure, $\card[d]{}$, given in the adjacent \lcnamecref{fig:string-rewriting:dec-measure}%
    \begin{marginfigure}
      \begin{equation*}
        \begin{lgathered}
          \card[d]{w \oc d} = \card[i]{w} + 3 \card{w} \\
          \card[d]{w \oc b'_0} = \card[d]{w} + 2 \\
          \card[d]{z} = 0 \\
          \card[d]{w \oc s} = \card[i]{w}
        \end{lgathered}
      \end{equation*}
      \caption{A termination measure for decrements, where $\card{w}$ denotes the length of string $w$}\label{fig:string-rewriting:dec-measure}
    \end{marginfigure}%
, that is strictly decreasing across each rewriting.
    Unlike the amortized constant work increments~\parencref[see proof of]{thm:string-rewriting:inc-small-step-adequacy}, this measure assigns a linear amount of potential to the decrement instruction.%
    \footnote[][0.5\baselineskip]{Actually, because the increment and decrement operations are defined only for binary representations, not head-unary forms, there can be at most one $d$.
      Therefore, it is actually possible to assign a constant amount of potential to each $d$.
      However, doing so would rely on a somewhat involved lexicographic measure that isn't particularly relevant to our aims in this dissertation, so we use the simpler linear potential.}%

    This measure is strictly decreasing across each rewriting: $w \reduces w'$ only if $\card[d]{w} > \card[d]{w'}$.
    As an example case, consider the intermediate state $w \oc b_0 \oc d$ and its rewriting $w \oc b_0 \oc d \reduces w \oc d \oc b'_0$.
    Indeed,
    \begin{equation*}
      \card[d]{w \oc b_0 \oc d}
        % = \card[i]{\octx \oc b_0} + 3\card{\octx \oc b_0}
        = \card[i]{w} + 3\card{w} + 3
        > \card[i]{w} + 3\card{w} + 2
        % = \card[d]{\octx \oc d} + 2
        = \card[d]{w \oc d \oc b'_0}
      \,.
    \qedhere
    \end{equation*}
  \end{description}
\end{proof}

\begin{restatable}[
  name=Big-step adequacy of decrements,
  label=cor:string-rewriting:dec-big-step-adequacy
]{corollary}{coradequacydecstring}
  If $\adec{w}{n}$, then:
  \begin{itemize}[nosep]
  \item $w \Reduces z$ if, and only if, $n = 0$;
  \item $w \Reduces w' \oc s$ for some $w'$ such that $\ainc{w'}{n-1}$, if $n > 0$; and
  \item $w \Reduces w' \oc s$ only if $n > 0$ and $\ainc{w'}{n-1}$.
  \end{itemize}
\end{restatable}
\begin{proof}
  From the small-step preservation result of \cref{thm:string-rewriting:dec-small-step-adequacy}, it is possible to prove, using a structural induction on the given trace, a big-step preservation result: namely, that $\adec{w}{n}$ and $w \Reduces w'$ only if $\adec{w'}{n}$.
  Each of the above claims then follows from either progress and termination~\parencref{thm:string-rewriting:dec-small-step-adequacy} or big-step preservation together with inversion.
\end{proof}

% $\adec{z}{n}$
% $\adec{\octx' \oc s}{n}$  ==>  $\ainc{\octx'}{n'}$ and $n = n'+1$
% 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
