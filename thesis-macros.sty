\ProvidesExplPackage
  {thesis-macros} {2018/08/25} {0.1}
  {Henry DeYoung's thesis macros}

\RequirePackage { l3keys2e }
\RequirePackage { xparse }

%%%%%%%%%%%%%
%% General %%
%%%%%%%%%%%%%

\DeclareMathOperator \cod { cod }

% mathabx symbols %

\RequirePackage { pifont }

\newcommand\Pimathsymbol[3][\mathord]{%
  #1{\@Pimathsymbol{#2}{#3}}}
\def\@Pimathsymbol#1#2{\mathchoice
  {\@Pim@thsymbol{#1}{#2}\tf@size}
  {\@Pim@thsymbol{#1}{#2}\tf@size}
  {\@Pim@thsymbol{#1}{#2}\sf@size}
  {\@Pim@thsymbol{#1}{#2}\ssf@size}}
\def\@Pim@thsymbol#1#2#3{%
  \mbox{\fontsize{#3}{#3}\Pisymbol{#1}{#2}}}

\DeclareFontFamily{U}{mathb}{\hyphenchar\font45}
\DeclareFontShape{U}{mathb}{m}{n}{
  <-6> mathb5 <6-7> mathb6 <7-8> mathb7
  <8-9> mathb8 <9-10> mathb9
  <10-12> mathb10 <12-> mathb12
  }{}

\newcommand{\blackdiamond}{\Pimathsymbol[\mathbin]{mathb}{"0C}}


\newcommand*\rel@kern[1]{\kern#1\dimexpr\macc@kerna}
\newcommand*\widebar[1]{%
  \begingroup
  \def\mathaccent##1##2{%
    \rel@kern{0.8}%
    \overline{\rel@kern{-0.8}\macc@nucleus\rel@kern{0.2}}%
    \rel@kern{-0.2}%
  }%
  \macc@depth\@ne
  \let\math@bgroup\@empty \let\math@egroup\macc@set@skewchar
  \mathsurround\z@ \frozen@everymath{\mathgroup\macc@group\relax}%
  \macc@set@skewchar\relax
  \let\mathaccentV\macc@nested@a
  \macc@nested@a\relax111{#1}%
  \endgroup
}

%%%%%%%%%%%%%%%%%%%
%% Ordered logic %%
%%%%%%%%%%%%%%%%%%%

\NewDocumentCommand \postfixjudgment { m }
  {
    \relax\ifnum\lastnodetype>0\mskip\medmuskip\fi\mathsf{#1}
  }

\NewDocumentCommand \ord { } { \postfixjudgment{ord} }
\NewDocumentCommand \ant { } { \postfixjudgment{ant} }

%%%%%%%%%%%%%%
%% Automata %%
%%%%%%%%%%%%%%

% just to make sure it exists
\providecommand \given { }
% can be useful to refer to this outside \Set
\NewDocumentCommand \SetSymbol { O{} } {
  \nonscript\medspace#1\vert
  \allowbreak
  \nonscript\medspace
  \mathopen{}
}

\DeclarePairedDelimiterX \Set [1] \{ \} {%
  \renewcommand \given { \SetSymbol[\delimsize] }
  #1
}

\NewDocumentCommand \rev { s m } {
  % \IfBooleanTF {#1}
    % { (#2)^{\mathsf{R}} }
    % { #2^{\mathsf{R}} }
  \underline{#2}
}

% for abbreviations and acronyms
\tex_let:D \c_minus_one \scan_stop:
\int_const:Nn \c_minus_one {-1}

\RequirePackage { acro }

\DeclareAcronym { NFA }
  {
    short = NFA ,
    long = nondeterministic~finite~automaton ,
    short-indefinite = an ,
    long-plural-form = nondeterministic~finite~automata
  }

\DeclareAcronym { DFA }
  {
    short = DFA ,
    long = deterministic~finite~automaton ,
    long-plural-form = deterministic~finite~automata
  }

\DeclareAcronym { SFT }
  {
    short = SFT ,
    long = subsequential~finite~transducer ,
    short-indefinite = an
  }

\DeclareAcronym { DPDA }
  {
    short = DPDA ,
    long = deterministic~pushdown~automaton ,
    long-plural-form = deterministic~pushdown~automata
  }

\DeclareAcronym { LCA }
  {
    short = LCA ,
    long = linear~communicating~automaton ,
    short-indefinite = an ,
    long-plural-form = linear~communicating~automata
  }

\NewDocumentCommand \wc { s }
  {
    \IfBooleanTF {#1}
      { \__thesis_wc_star: }
      { \__thesis_wc: }
  }
\cs_new:Npn \__thesis_wc: { \mkern2mu }
\cs_new:Npn \__thesis_wc_star: { \mathbin { \cdot } }

\NewDocumentCommand \emp { } { \__thesis_emp: }
\cs_new:Npn \__thesis_emp: { \epsilon }

\NewDocumentCommand \aut { m } { \__thesis_aut:n {#1} }
\cs_new:Npn \__thesis_aut:n #1
  { \mathord { \mathcal {#1} } }

\NewDocumentCommand \ialph { } { \__thesis_ialph: }
\cs_new:Npn \__thesis_ialph: { \Sigma }

\NewDocumentCommand \finwds { m } { \__thesis_finwds:n {#1} }
\cs_new:Npn \__thesis_finwds:n #1 { #1 ^* }

\NewDocumentCommand \infinwds { m } { \__thesis_infinwds:n {#1} }
\cs_new:Npn \__thesis_infinwds:n #1 { #1 ^{\omega} }

\NewDocumentCommand \wds { m } { \__thesis_wds:n {#1} }
\cs_new:Npn \__thesis_wds:n #1 { #1 ^{\infty} }

\NewDocumentCommand \augalph { m m } { \__thesis_augalph:nn {#1} {#2} }
\cs_new:Npn \__thesis_augalph:nn #1 #2 { #1 \sb{#2} }

\NewDocumentCommand \oalph { } { \__thesis_oalph: }
\cs_new:Npn \__thesis_oalph: { \Gamma }

\NewDocumentCommand \sftnext { } { \__thesis_sftnext: }
\cs_new:Npn \__thesis_sftnext: { \delta }

\NewDocumentCommand \sftout { } { \__thesis_sftout: }
\cs_new:Npn \__thesis_sftout: { \sigma }

\NewDocumentCommand \sftterm { } { \__thesis_sftterm: }
\cs_new:Npn \__thesis_sftterm: { \rho }

\NewDocumentCommand \salph { } { \__thesis_salph: }
\cs_new:Npn \__thesis_salph: { \Gamma }

\NewDocumentCommand \nfareduces { o }
  {
    \IfNoValueTF {#1}
      { \__thesis_nfareduces: }
      { \__thesis_nfareduces:n {#1} }
  }
\cs_new:Npn \__thesis_nfareduces: { \longrightarrow }
\cs_new:Npn \__thesis_nfareduces:n #1
  { \overset {#1} { \__thesis_nfareduces: } }

\cs_set_eq:NN \dfareduces \nfareduces

\NewDocumentCommand \dfanext { } { \__thesis_dfanext: }
\cs_new:Npn \__thesis_dfanext: { \delta }

\NewDocumentCommand \nfapow { } { \__thesis_nfapow: }
\cs_new:Npn \__thesis_nfapow: { \Delta }

\NewDocumentCommand \nfaReduces { o }
  {
    \IfNoValueTF {#1}
      { \__thesis_nfaReduces: }
      { \__thesis_nfaReduces:n {#1} }
  }
\cs_new:Npn \__thesis_nfaReduces: { \Longrightarrow }
\cs_new:Npn \__thesis_nfaReduces:n #1
  { \overset {#1} { \__thesis_nfaReduces: } }

\NewDocumentCommand \sftReduces { o }
  {
    \IfNoValueTF {#1}
      { \__thesis_sftReduces: }
      { \__thesis_sftReduces:n {#1} }
  }
\cs_new:Npn \__thesis_sftReduces: { \Longrightarrow }
\cs_new:Npn \__thesis_sftReduces:n #1
  { \overset {#1} { \__thesis_sftReduces: } }

\NewDocumentCommand \sftReducesEnd { o }
  {
    \IfNoValueTF {#1}
      { \__thesis_sftReducesEnd: }
      { \__thesis_sftReducesEnd:n {#1} }
  }
\cs_new:Npn \__thesis_sftReducesEnd: { \mathrel{\Longrightarrow\mkern1mu\Mapsfromchar} }
\cs_new:Npn \__thesis_sftReducesEnd:n #1
  { \overset {#1} { \__thesis_sftReducesEnd: } }

\NewDocumentCommand \sftreduces { o }
  {
    \IfNoValueTF {#1}
      { \__thesis_sftreduces: }
      { \__thesis_sftreduces:n {#1} }
  }
\cs_new:Npn \__thesis_sftreduces: { \longrightarrow }
\cs_new:Npn \__thesis_sftreduces:n #1
  { \overset {#1} { \__thesis_sftreduces: } }


\NewDocumentCommand \rL { m } { #1^{\mathsf{rL}} }
\NewDocumentCommand \rR { m } { #1^{\mathsf{rR}} }
\NewDocumentCommand \wL { m } { #1^{\mathsf{wL}} }
\NewDocumentCommand \wR { m } { #1^{\mathsf{wR}} }
\NewDocumentCommand \fS { m } { #1^{\mathsf{f}} }
\NewDocumentCommand \hS { m } { #1^{\mathsf{h}} }



\NewDocumentCommand \autlang { m m } { \__thesis_autlang:nn {#1} {#2} }
\cs_new:Npn \__thesis_autlang:nn #1 #2 { \mathcal { L } \sb{#1} ( #2 ) }

\NewDocumentCommand \tio { >{ \SplitArgument { 1 } { | } } m }
  { \__thesis_tio:nn #1 }
\cs_new:Npn \__thesis_tio:nn #1#2 { #1 \mid #2 }

\tikzgraphsset
  {
    automaton / .style = {
      math~nodes , nodes = state ,
      edges = { node~quotes~mean / .try = { label=$########1$ } } ,
      grow~right~sep = 1.5em
    }
  }

\NewDocumentCommand \nfa { m } { \__thesis_nfa:n {#1} }
\cs_new:Npn \__thesis_nfa:n #1 { \hat {#1} }

\cs_set_eq:NN \dfa \nfa

\NewDocumentCommand \nfawds { m } { \__thesis_nfawds:n {#1} }
\cs_new:Npn \__thesis_nfawds:n #1 { \mkern1mu \underline { \mkern-1mu #1 \mkern-1mu } \mkern1mu }

\NewDocumentCommand \sft { m } { \__thesis_sft:n {#1} }
\cs_new:Npn \__thesis_sft:n #1 { \hat {#1} }

\NewDocumentCommand \asim { } { \__thesis_asim: }
\cs_new:Npn \__thesis_asim: { \sim }

\NewDocumentCommand \misa { } { \__thesis_misa: }
\cs_new:Npn \__thesis_misa: { \__thesis_asim: ^{-1} }

\NewDocumentCommand \tape { o }
  {
    \IfNoValueTF {#1}
      \__thesis_tape:
      { \__thesis_tape: \sb{#1} }
  }
\cs_new:Npn \__thesis_tape: { \text{\sffamily tape} }


%%%%%%%%%%%%%%%%%%%
%% Ordered logic %%
%%%%%%%%%%%%%%%%%%%

\NewDocumentCommand \oseq { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_oseq:nn #1 }
\cs_new:Npn \__thesis_oseq:nn #1#2 { #1 \vdash #2 }

\NewDocumentCommand \oseqv { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_oseqv:nn #1 }
\cs_new:Npn \__thesis_oseqv:nn #1#2 { #1 \vdash^{ \mathrm{cf},\ell } #2 }

\NewDocumentCommand \oseql { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_oseql:nn #1 }
\cs_new:Npn \__thesis_oseql:nn #1#2 { #1 \vdash^{ \ell } #2 }

\NewDocumentCommand \oseqcf { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_oseqcf:nn #1 }
\cs_new:Npn \__thesis_oseqcf:nn #1#2 { #1 \vdash^{ \mathrm{cf} } #2 }

\NewDocumentCommand \cseq { } { \__thesis_cseq: }
\cs_new:Npn \__thesis_cseq: { \gamma }

\NewDocumentCommand \cseqe { } { \__thesis_cseqe: }
\cs_new:Npn \__thesis_cseqe: { \cdot }


%%%%%%%%%%%%%%%%%%%%%%%
%% Ordered rewriting %%
%%%%%%%%%%%%%%%%%%%%%%%

\DeclarePairedDelimiter \card { \lvert } { \rvert }

\tikzcdset{
  reduces / .style = { rightarrow } ,
  Reduces / .style = { Rightarrow }
}


\DeclarePairedDelimiterXPP{\cval}[1]{\mathbb{V}}(){}{
  \tl_if_empty:nTF {#1} { \mathord{-} } {#1} }


\RequirePackage { accents }

\NewDocumentCommand \atmR { m } { \__thesis_atmR:n {#1} }
\cs_new:Npn \__thesis_atmR:n #1
  { \underaccent { \vec } {#1} }

\NewDocumentCommand \atmL { m } { \__thesis_atmL:n {#1} }
\cs_new:Npn \__thesis_atmL:n #1
  { \mathrlap { \reflectbox { $ \atmR { \phantom {#1} } $ } } #1 }


%%%%%%%%%%%%%%%%%%%%%
%% Singleton logic %%
%%%%%%%%%%%%%%%%%%%%%

\NewDocumentCommand \sctx { } { \__thesis_sctx: }
\cs_new:Npn \__thesis_sctx: { \delta }

\NewDocumentCommand \sctxe { } { \__thesis_sctxe: }
\cs_new:Npn \__thesis_sctxe: { \cdot }

\NewDocumentCommand \slseq { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_slseq:nn #1 }
\cs_new:Npn \__thesis_slseq:nn #1#2 { #1 \vdash #2 }

\NewDocumentCommand \cfslseq { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_cfslseq:nn #1 }
\cs_new:Npn \__thesis_cfslseq:nn #1#2 { #1 \vdash^{\mathrm{cf}} #2 }

\cs_new:Npn \__thesis_pred_font:n #1 { \mathit {#1} }

\NewDocumentCommand \nspawn { o m m } { \__thesis_nspawn:nn {#2} {#3} }
\cs_new:Npn \__thesis_nspawn:nn #1 #2 { #1 \mathbin{\blackdiamond} #2 }

\NewDocumentCommand \proc { m } { \__thesis_proc:n {#1} }
\cs_new:Npn \__thesis_proc:n #1 { \__thesis_pred_font:n { proc } (#1) }

\NewDocumentCommand \msgR { m } { \__thesis_msgR:n {#1} }
\cs_new:Npn \__thesis_msgR:n #1 { \__thesis_pred_font:n { msgR } (#1) }

\NewDocumentCommand \msgL { m } { \__thesis_msgL:n {#1} }
\cs_new:Npn \__thesis_msgL:n #1 { \__thesis_pred_font:n { msgL } (#1) }

\NewDocumentCommand \slof { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_slof:nn #1 }
\cs_new:Npn \__thesis_slof:nn #1#2 { #1 \vdash #2 }

\NewDocumentCommand \multipremise { m m }
  { \__thesis_multipremise:nn {#1} {#2} }
\cs_new:Npn \__thesis_multipremise:nn #1#2 { \forall #1 \colon\enspace #2 }

\NewDocumentCommand \slofp { > { \SplitArgument { 1 } { ||- } } m }
  { \__thesis_slofp:nn #1 }
\cs_new:Npn \__thesis_slofp:nn #1#2 { #1 \Vdash #2 }

\NewDocumentCommand \slofn { > { \SplitArgument { 1 } { ||- } } m }
  { \__thesis_slofn:nn #1 }
\cs_new:Npn \__thesis_slofn:nn #1#2 { [#1] \Vdash #2 }

\NewDocumentCommand \ce { m } { \__thesis_ce:n {#1} }
\cs_new:Npn \__thesis_ce:n #1 { \mathit{ce}(#1) }

\NewDocumentCommand \slcof { > { \SplitArgument { 1 } { |- } } m }
  { \__thesis_slcof:nn #1 }
\cs_new:Npn \__thesis_slcof:nn #1#2 { #1 \Vdash #2 }

\NewDocumentCommand \pf { s m }
  {
    \IfBooleanTF {#1}
      { \__thesis_pf_star:n {#2} }
      { \__thesis_pf:n {#2} }
  }
\cs_new:Npn \__thesis_pf:n #1 { #1^{\sharp} }
\cs_new:Npn \__thesis_pf_star:n #1 { \pf{(#1)} }

\NewDocumentCommand \dnf { } { \__thesis_dnf: }
\cs_new:Npn \__thesis_dnf: { \mathcal { D } }

\NewDocumentCommand \tsim { } { \__thesis_tsim: }
\cs_new:Npn \__thesis_tsim: { \cong }

\NewDocumentCommand \mist { } { \__thesis_mist: }
\cs_new:Npn \__thesis_mist: { \mathrel { \__thesis_tsim: ^{-1} } }

%%%%%%%%%%%
%% Other %%
%%%%%%%%%%%

\NewDocumentCommand \downsquigarrow { } { \__thesis_downsquigarrow: }
\cs_new:Npn \__thesis_downsquigarrow:
  { \mathrel { \mathpalette \__thesis_rotate_squig:nn \relax } }
\cs_new:Npn \__thesis_rotate_squig:nn #1 #2
  { \rotatebox[origin=c]{270}{$\m@th#1\rightsquigarrow$} }


\NewDocumentCommand \cutreduces { } { \__thesis_cutreduces: }
\cs_new:Npn \__thesis_cutreduces: { \rightsquigarrow }

\NewDocumentCommand \union { } { \__thesis_union: }
\cs_new:Npn \__thesis_union: { \mathbin { \cup } }


\providecommand \given { }
\newcommand \GivenSymbol [1] [] {
  \nonscript\muskip\medmuskip#1\vert
  \allowbreak
  \nonscript\muskip\medmuskip
  \mathopen{}
}
\DeclarePairedDelimiterX \set [1] \lbrace \rbrace {
  \renewcommand \given { \GivenSymbol[\delimsize] }
  #1
}

\NewDocumentCommand \bigwith { } { \__thesis_bigwith: }
\cs_new:Npn \__thesis_bigwith:
  {
    \mathop {
      \mathchoice { \__thesis_bigwith:N \LARGE }
                  { \__thesis_bigwith:N \large }
                  { \__thesis_bigwith:N \normalsize }
                  { \__thesis_bigwith:N \small } }
  }
\cs_new:Npn \__thesis_bigwith:N #1
  { \vcenter { #1 \kern.2ex \hbox:n {$\mathord{\binampersand}$} \kern.2ex } }

\NewDocumentCommand \simu { m } { \__thesis_simu:n {#1} }
\cs_new:Npn \__thesis_simu:n #1
  { \mathrel { \mathcal {#1} } }

\NewDocumentCommand \refl { s m }
  {
    \IfBooleanTF {#1}
      { \__thesis_refl_star:n {#2} }
      { \__thesis_refl:n {#2} }
  }
\cs_new:Npn \__thesis_refl:n #1
  { \mathrel { #1 ^{ \mathord{=} } } }
\cs_new:Npn \__thesis_refl_star:n #1
  { \mathrel { ( \__thesis_refl:n {#1} ) } }

\NewDocumentCommand \congrel { s m }
  {
    \IfBooleanTF {#1}
      { \__thesis_congrel_star:n {#2} }
      { \__thesis_congrel:n {#2} }
  }
\cs_new:Npn \__thesis_congrel:n #1
  { \mathrel { [ #1 ] } }
\cs_set_eq:NN \__thesis_congrel_star:n \__thesis_congrel:n

\NewDocumentCommand \osim { } { \__thesis_osim: }
\cs_new:Npn \__thesis_osim: { \mathrel { \cong } }

\NewDocumentCommand \miso { } { \__thesis_miso: }
\cs_new:Npn \__thesis_miso: { \mathrel { \cong } ^ {-1} }

\NewDocumentCommand \lrframe { m m m }
  { \__thesis_lrframe:nnn {#1} {#2} {#3} }
\cs_new:Npn \__thesis_lrframe:nnn #1#2#3
  { \mathrel { ( #1 \mathord{#2} #3 ) } }

\NewDocumentCommand \lframe { m m }
  { \__thesis_lframe:nn {#1} {#2} }
\cs_new:Npn \__thesis_lframe:nn #1#2
  { \__thesis_lrframe:nnn {#1} {#2} { } }

\NewDocumentCommand \rframe { m m }
  { \__thesis_rframe:nn {#1} {#2} }
\cs_new:Npn \__thesis_rframe:nn #1#2
  { \__thesis_lrframe:nnn { } {#1} {#2} }


\cs_new:Npn \__thesis_tmp:n #1 {#1}

\NewDocumentCommand \ireduces { m m m }
  {
    \group_begin:
      \cs_set:Npn \__thesis_tmp:n ##1 {#1}
      \__thesis_ireduces:Nnn \__thesis_tmp:n {#2} {#3}
    \group_end:
  }
\cs_new_protected:Npn \__thesis_ireduces:Nnn #1#2#3
  { #1 { [#2] } \reduces #3 }

\NewDocumentCommand \trproc { m } { \__thesis_trproc:n {#1} }
\cs_new:Npn \__thesis_trproc:n #1 { \llbracket #1 \rrbracket }

\NewDocumentCommand \trconf { m } { \__thesis_trconf:n {#1} }
\cs_new:Npn \__thesis_trconf:n #1 { \llbracket #1 \rrbracket }

\NewDocumentCommand \vocab { m } { \emph {#1} }


%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inferences environment %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\NewDocumentEnvironment { inferences } { }
  { \__thesis_inferences_begin: }
  { \__thesis_inferences_end: }

\cs_new_protected:Npn \__thesis_inferences_begin:
  {
    \group_begin:
      \cs_set_eq:NN \and \qquad
      \use:c { spreadlines } { \jot + 1.5ex }
        \use:c { gather* }
  }

\cs_new_protected:Npn \__thesis_inferences_end:
  {
        \use:c { endgather* }
      \use:c { endspreadlines }
    \group_end:
  }


%%%%%%%%%%%%%%%%%%%%%%
% Syntax environment %
%%%%%%%%%%%%%%%%%%%%%%

\RequirePackage { array }
\RequirePackage { collcell }
\RequirePackage { textcase }

\cs_new_protected:Npn \__thesis_syntext:n #1
  {
    \text {
      \color { structure } \scshape
      \MakeTextLowercase {#1}
    }
  }

\NewDocumentEnvironment { syntax* } { }
  { \__thesis_syntaxstar_begin: }
  { \__thesis_syntaxstar_end: }

\cs_new_protected:Npn \__thesis_syntaxstar_begin:
  {
    \group_begin:
      \use:c { equation* }
        \cs_set:Npn \arraystretch { 1.5 }
        \use:c { array }
          {
            @{}
            >{ \collectcell \__thesis_syntext:n }
            r
            <{ \endcollectcell }
            @{ \quad }
            r
            @{ {} \Coloneqq {} }
            >{ \renewcommand\arraystretch{1} }
            l
            @{} 
          }
  }

\cs_new_protected:Npn \__thesis_syntaxstar_end:
  {
        \use:c { endarray }
      \use:c { endequation* }
    \group_end:
  }
